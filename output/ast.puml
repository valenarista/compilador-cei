' Generated by UML Generator
' Encoded: tLfPRziu47xthz2ZdDh5FXj5qIPeiGRID4ZIz9cnc9Y8B1eI7TJTuxSl3ntap52MxQRfziK7v-FS70r9lQiKAzLcbO-gHr6iMSbMoI9dLVLUgLBSRHIVBsHnBRxpv8_HKcGyMOXoaVFHoAAIioKJ1S_EM9vVI4tzQvGaKoKVUJ5BRioN-R_YQYcp2xRYi-HQioqUpAXSAo4BbbiMUcoMDByC9uDWvSEvgDGiCPzlFdnRbxogz1n3Vsi0K_tn2gYG-j8d2POzDfD4zNdDIrPaNuLQcgdfU9RSIPbpLZZwBIi5kyiv85HSlNTgfNbKDptbIOhCu1-uifeODer3pE1dOBsX0_kDB0rh4GkF788zUOibNpocMfid8JVLpNQjeUPpxBuCf93giXGheSGJDwPRtkuxm0SiFra_VlYchUN5WkC9bAidYHyCpT9n6Vq3qaVxEfuzk_FaIKy7oSMQz9qbRIR3ZAcbWeG1p8xEbcU8u7JF24ujozOFjomNcL3R-1GT7tPNgP8jLE85gjRLXgbMqtwY33lCNsrMlDShwQ7eCYBdztgXXMlCZ9VYOKaIO0gfri8s1pePASL-af3CGK9tVl2CPoK_ayMzB5UiK6QmiXBybM9v1sxtdAEBmxbEJyDI5Agf8Hhc2p4W_eslx62RzjgnpYxaxwFYSIeALcwr9xgGICDFoT9piZ7oMfZ4ZaGgHhJn26IaCLwJ10YkVKbXnssbTJDW1JwlPPXnf9G1N3MSQSHp15vBuGl5CpSRs1g6_ufNczpbHIyEvzBFI1nOFkHgtUKFfeVUTGKcMbIHuv_LodOLN6po_DVM4pYr1dUQahq8U4J9xZVzX6hzyML8KP1EXvclJAGY-_nIjCmfHcDw6eKQ5ejdhRADB-RLgHjB5Lq8Ek2yKFqWxQ5vTS4Vc6cHqXZ0iDcluBk1Sw4qYvx6tbLk14xHGpBM1KE77xXa_7wo7AOrGBwSoZeumpGEWI-XCAWlKEru9HoYnRvrw4UKys6E1yYNInNtVvZI2Fk2Yr8MEcys2rsB-iy9B9mu9ZZwX00h03PzIF8OxFLx1ONR_MRAEAfLrFDdZHhXysRNMXcqhNonLj0bWTlv7tXET6m2XCA7dH3zzE1_QlNu_Q9_gVT6XHBVUKPqq5FUZb7RmztdFpR6CH5fdFluV-DUCcU6Rhwk-3qlpQ4TFBmvncZleQIRpmMrl7S7pdAu8Qi071ssq2bbKYIbMVCtkyvotC6PpxGxEnl4zEYi6b1F3YjKlr2wkZowMOeAP-eFw15iOY3kWng0tx0srCwMMw8gmD7qztQ29lRt8yIzmkvCyxWEk5c8DGEt3Xlwve0jqiyzWxBqItE9oFM-0r7EvOBbsZ94QAyczZocoENYiGjVfP__9dMhklvTr__RHuGEW5NX4rlFaZzPjTG_tZGtLRSriKKNl58ycnUsATUjWsukrDR-yQdpuadFqXhEalQdeQzjEs8rd7MATeScpOXROopB6ctJnWmT3C-0S2qrbAfzC41ZwoHgx3KuO34qsAJNPQTrIbiGwk7Znw6TXbshfdqwzSR7uwkTqUYMDY6R1V4vfB2qAo5iNpwirchhQs9pwLzoJusmBdXuE7v9vAjDA0ciQRNyA4lTXHGPAxlZtAbUxqheVkIxFVqBqyK-AcMXMvL8LxrPPqoHrp5tCjjYPjO1G8sqJmFzJ8t9doIqTDfLEezEjKefrWi5StxVUQVNUjf6dbVyD6wzuvxsc8NPJXAQwQ6ckXone35IqzuWrU8GEJZu2Yldgs0e7VSibokkDcMuTMilhBgscGT-eG9mB_J6u8PQP9s4j9zDr8KVMzuf4dF84WJRALGii1AHP-U-ntsr8FEaxTysx-_bEEyXNdStbVwa_XlI7-ANVOFh8Tlcok_zsgT9tVm56Imol-jxOlc63tdHW5dpI8_x4hrB7UADWX09MaX2aKc2nOw7PtZqwckU3Ue8OPJTflb2Uhr1TIOBfVlJklSBIyhNfSZvKNNR-hTbir-1VhP2VDPeGQmDRJjySMuw_VjjkA60Y9Ffj1yWDG080kzNHOKq02J3UnN7JWRyFV89bXw-D-A4Toy2038nttzhW99EtCXJCFyUV1VzzMlWe2-z9do15lZNtCGjgcNW3OpWXIK2WEj1H4T4NmEVY2o35s28DRvkmkeJLpiM59mZa32SpWI8I6bmqaX80mWa2D096T7ZQa9Q57ko1r-aOtWwWm8Rab5eoJDPGdSIXtGXKOJNy0aU8HA3a3nqE4MnWHZa0_zqXs3Wav46NNjiPmRLlQCP5_IG_CUuHpB2kdqotdvYYN3pjnjn0ZMZ021wzTu9Cwy9yIb8MhZ3i1mxYxqTH20BTw8-b93UqnvZ8th01EkWEyJC0Z8nlUjeyDoErZiH-VGTBxBDAlyF
' URL: http://www.plantuml.com/plantuml/uml/tLfPRziu47xthz2ZdDh5FXj5qIPeiGRID4ZIz9cnc9Y8B1eI7TJTuxSl3ntap52MxQRfziK7v-FS70r9lQiKAzLcbO-gHr6iMSbMoI9dLVLUgLBSRHIVBsHnBRxpv8_HKcGyMOXoaVFHoAAIioKJ1S_EM9vVI4tzQvGaKoKVUJ5BRioN-R_YQYcp2xRYi-HQioqUpAXSAo4BbbiMUcoMDByC9uDWvSEvgDGiCPzlFdnRbxogz1n3Vsi0K_tn2gYG-j8d2POzDfD4zNdDIrPaNuLQcgdfU9RSIPbpLZZwBIi5kyiv85HSlNTgfNbKDptbIOhCu1-uifeODer3pE1dOBsX0_kDB0rh4GkF788zUOibNpocMfid8JVLpNQjeUPpxBuCf93giXGheSGJDwPRtkuxm0SiFra_VlYchUN5WkC9bAidYHyCpT9n6Vq3qaVxEfuzk_FaIKy7oSMQz9qbRIR3ZAcbWeG1p8xEbcU8u7JF24ujozOFjomNcL3R-1GT7tPNgP8jLE85gjRLXgbMqtwY33lCNsrMlDShwQ7eCYBdztgXXMlCZ9VYOKaIO0gfri8s1pePASL-af3CGK9tVl2CPoK_ayMzB5UiK6QmiXBybM9v1sxtdAEBmxbEJyDI5Agf8Hhc2p4W_eslx62RzjgnpYxaxwFYSIeALcwr9xgGICDFoT9piZ7oMfZ4ZaGgHhJn26IaCLwJ10YkVKbXnssbTJDW1JwlPPXnf9G1N3MSQSHp15vBuGl5CpSRs1g6_ufNczpbHIyEvzBFI1nOFkHgtUKFfeVUTGKcMbIHuv_LodOLN6po_DVM4pYr1dUQahq8U4J9xZVzX6hzyML8KP1EXvclJAGY-_nIjCmfHcDw6eKQ5ejdhRADB-RLgHjB5Lq8Ek2yKFqWxQ5vTS4Vc6cHqXZ0iDcluBk1Sw4qYvx6tbLk14xHGpBM1KE77xXa_7wo7AOrGBwSoZeumpGEWI-XCAWlKEru9HoYnRvrw4UKys6E1yYNInNtVvZI2Fk2Yr8MEcys2rsB-iy9B9mu9ZZwX00h03PzIF8OxFLx1ONR_MRAEAfLrFDdZHhXysRNMXcqhNonLj0bWTlv7tXET6m2XCA7dH3zzE1_QlNu_Q9_gVT6XHBVUKPqq5FUZb7RmztdFpR6CH5fdFluV-DUCcU6Rhwk-3qlpQ4TFBmvncZleQIRpmMrl7S7pdAu8Qi071ssq2bbKYIbMVCtkyvotC6PpxGxEnl4zEYi6b1F3YjKlr2wkZowMOeAP-eFw15iOY3kWng0tx0srCwMMw8gmD7qztQ29lRt8yIzmkvCyxWEk5c8DGEt3Xlwve0jqiyzWxBqItE9oFM-0r7EvOBbsZ94QAyczZocoENYiGjVfP__9dMhklvTr__RHuGEW5NX4rlFaZzPjTG_tZGtLRSriKKNl58ycnUsATUjWsukrDR-yQdpuadFqXhEalQdeQzjEs8rd7MATeScpOXROopB6ctJnWmT3C-0S2qrbAfzC41ZwoHgx3KuO34qsAJNPQTrIbiGwk7Znw6TXbshfdqwzSR7uwkTqUYMDY6R1V4vfB2qAo5iNpwirchhQs9pwLzoJusmBdXuE7v9vAjDA0ciQRNyA4lTXHGPAxlZtAbUxqheVkIxFVqBqyK-AcMXMvL8LxrPPqoHrp5tCjjYPjO1G8sqJmFzJ8t9doIqTDfLEezEjKefrWi5StxVUQVNUjf6dbVyD6wzuvxsc8NPJXAQwQ6ckXone35IqzuWrU8GEJZu2Yldgs0e7VSibokkDcMuTMilhBgscGT-eG9mB_J6u8PQP9s4j9zDr8KVMzuf4dF84WJRALGii1AHP-U-ntsr8FEaxTysx-_bEEyXNdStbVwa_XlI7-ANVOFh8Tlcok_zsgT9tVm56Imol-jxOlc63tdHW5dpI8_x4hrB7UADWX09MaX2aKc2nOw7PtZqwckU3Ue8OPJTflb2Uhr1TIOBfVlJklSBIyhNfSZvKNNR-hTbir-1VhP2VDPeGQmDRJjySMuw_VjjkA60Y9Ffj1yWDG080kzNHOKq02J3UnN7JWRyFV89bXw-D-A4Toy2038nttzhW99EtCXJCFyUV1VzzMlWe2-z9do15lZNtCGjgcNW3OpWXIK2WEj1H4T4NmEVY2o35s28DRvkmkeJLpiM59mZa32SpWI8I6bmqaX80mWa2D096T7ZQa9Q57ko1r-aOtWwWm8Rab5eoJDPGdSIXtGXKOJNy0aU8HA3a3nqE4MnWHZa0_zqXs3Wav46NNjiPmRLlQCP5_IG_CUuHpB2kdqotdvYYN3pjnjn0ZMZ021wzTu9Cwy9yIb8MhZ3i1mxYxqTH20BTw8-b93UqnvZ8th01EkWEyJC0Z8nlUjeyDoErZiH-VGTBxBDAlyF
' Generated on: 2025-10-29T10:46:43.715181100

@startuml
skinparam classAttributeIconSize 0
hide circle

class ChainedCallNode {
  -token: Token
  -methodName: String
  -optionalChaining: ChainingNode
  -argList: List<ExpressionNode>
  --
  +ChainedCallNode(token: Token, methodName: String)
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +setArgList(list: List<ExpressionNode>): void
  +getToken(): Token
  +getOptionalChaining(): ChainingNode
  +setOptChaining(chainingNode: ChainingNode): void
  +check(previousType: Type): Type
  +notPrimitiveCalling(callingType: Type): void
  +checkMethodExistence(callingType: Type, methodName: String, token: Token): Method
}

class ChainedVarNode {
  -token: Token
  -optionalChaining: ChainingNode
  -varName: String
  -attribute: Attribute
  --
  +ChainedVarNode(token: Token, varName: String)
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +setOptChaining(chainingNode: ChainingNode): void
  +check(previousType: Type): Type
  -notPrimitiveCalling(callingType: Type): void
  -checkAttributeValidity(callingType: Type): void
}

abstract class ChainingNode {
  +check(check: Type): Type
  +isOperandWithCall(): boolean
  +isVariable(): boolean
}

class AssignNode {
  -left: ExpressionNode
  -right: ExpressionNode
  -token: Token
  -type: Type
  --
  +AssignNode(left: ExpressionNode, right: ExpressionNode, token: Token)
  +check(): Type
  +areConformantTypes(leftType: Type, rightType: Type): boolean
  +getLine(): int
  +getType(): Type
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isVariable(): boolean
}

class BinaryExpNode {
  -operator: Token
  -leftSide: ExpressionNode
  -rightSide: ExpressionNode
  --
  +BinaryExpNode(leftSide: ExpressionNode, operator: Token, rightSide: ExpressionNode)
  +getOperator(): Token
  +getLeftSide(): ExpressionNode
  +getRightSide(): ExpressionNode
  +check(): Type
  +areConformantTypes(leftType: Type, rightType: Type): boolean
  +getExpectedTypes(operator: Token): Type
  +getResultType(operator: Token): Type
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isVariable(): boolean
}

abstract class CompExpNode {
}

abstract class ExpressionNode {
  +isVariable(): boolean
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
}

class NullExpressionNode {
  +isVariable(): boolean
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
}

abstract class OperandNode {
  +getToken(): Token
  +setOptChaining(optChaining: ChainingNode): void
}

class UnaryExpNode {
  -operator: Token
  -operand: OperandNode
  -type: Type
  --
  +UnaryExpNode(operator: Token, operand: OperandNode)
  +UnaryExpNode(operand: OperandNode)
  +check(): Type
  +getLine(): int
  +getType(): Type
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  -operandIsBoolean(type: Type): boolean
  -operandIsInt(type: Type): boolean
  -operatorIsNegation(): boolean
  -operatorIsInt(): boolean
  +isVariable(): boolean
}

class BooleanLiteralNode {
  -token: Token
  --
  +BooleanLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
}

class CharLiteralNode {
  -token: Token
  --
  +CharLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
}

class IntLiteralNode {
  -token: Token
  --
  +IntLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
}

abstract class LiteralNode {
  +isVariable(): boolean
  +getType(): Type
  +check(): Type
  +setOptChaining(optChaining: ChainingNode): void
  +isAssign(): boolean
  +isOperandWithCall(): boolean
}

class NullLiteralNode {
  -token: Token
  --
  +NullLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
}

class StringLiteralNode {
  -token: Token
  --
  +StringLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
}

class ConstructorCallNode {
  -token: Token
  -className: String
  -optChaining: ChainingNode
  -argList: List<ExpressionNode>
  --
  +ConstructorCallNode(token: Token, className: String)
  +setArgList(argList: List<ExpressionNode>): void
  +getArgList(): List<ExpressionNode>
  +getToken(): Token
  +getClassName(): String
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isVariable(): boolean
}

class MethodCallNode {
  -token: Token
  -methodName: String
  -optChaining: ChainingNode
  -argList: List<ExpressionNode>
  --
  +MethodCallNode(token: Token, methodName: String)
  +setArgList(argList: List<ExpressionNode>): void
  +getArgList(): List<ExpressionNode>
  +getToken(): Token
  +getMethodName(): String
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isVariable(): boolean
}

class ParentizedExpressionNode {
  -expression: ExpressionNode
  -optionalChaining: ChainingNode
  --
  +ParentizedExpressionNode(expression: ExpressionNode)
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +getToken(): Token
  +isVariable(): boolean
}

abstract class ReferenceNode {
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
}

class StaticMethodCallNode {
  -optionalChaining: ChainingNode
  -classToken: Token
  -methodToken: Token
  -argList: List<ExpressionNode>
  --
  +StaticMethodCallNode(classToken: Token, methodToken: Token)
  +check(): Type
  -checkStaticMethodValidity(classToken: Token, methodToken: Token): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getArgList(): List<ExpressionNode>
  +setArgList(argList: List<ExpressionNode>): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +getToken(): Token
  +isVariable(): boolean
}

class ThisReferenceNode {
  -token: Token
  -className: String
  -optChaining: ChainingNode
  --
  +ThisReferenceNode(token: Token, className: String)
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +getToken(): Token
  +isVariable(): boolean
}

class ToyReferenceNode {
  +ToyReferenceNode()
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +getToken(): Token
  +isVariable(): boolean
}

class VarCallNode {
  -token: Token
  -varName: String
  -optChaining: ChainingNode
  --
  +VarCallNode(token: Token, varName: String)
  +getToken(): Token
  +getVarName(): String
  +setOptChaining(optChaining: ChainingNode): void
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isParameter(): boolean
  +isLocalVar(): boolean
  +isAttribute(): boolean
  +isVariable(): boolean
}

class BlockNode {
  -sentences: List<SentenceNode>
  -varLocalMap: HashMap<String, VarLocalNode>
  -nestedInClass: EntityClass
  -nestedInInvocable: Invocable
  -parentBlock: BlockNode
  --
  +BlockNode()
  +addSentence(sentence: SentenceNode): void
  +getSentences(): List<SentenceNode>
  +getVarLocalMap(): HashMap<String,VarLocalNode>
  +setParentBlock(parentBlock: BlockNode): void
  +getParentBlock(): BlockNode
  +setSentencesList(sentences: List<SentenceNode>): void
  +addVarLocal(varLocal: VarLocalNode): void
  +getLine(): int
  +getLexeme(): String
  +check(): void
}

class EmptySentenceNode {
  ~token: Token
  --
  +EmptySentenceNode()
  +EmptySentenceNode(token: Token)
  +check(): void
  +getLexeme(): String
  +getLine(): int
}

class ForStandardNode {
  -initialization: SentenceNode
  -condition: ExpressionNode
  -update: ExpressionNode
  -body: SentenceNode
  --
  +ForStandardNode(initialization: SentenceNode, condition: ExpressionNode, update: ExpressionNode)
  +check(): void
  +setBody(body: SentenceNode): void
}

class IfNode {
  -condition: ExpressionNode
  -body: SentenceNode
  -elseBody: SentenceNode
  --
  +IfNode(condition: ExpressionNode, body: SentenceNode, elseBody: SentenceNode)
  +check(): void
  +setBody(body: SentenceNode): void
  +getBody(): SentenceNode
  +getElseBody(): SentenceNode
}

class NullBlockNode {
  +NullBlockNode()
  +check(): void
}

class ReturnNode {
  -expectedType: Type
  -expressionNode: ExpressionNode
  -finalToken: Token
  --
  +ReturnNode(expressionNode: ExpressionNode)
  +check(): void
  +setFinalToken(finalToken: Token): void
  +getLexeme(): String
  +getLine(): int
}

abstract class SentenceNode {
  +check(): void
  +isAssign(): boolean
  +getLine(): int
  +getLexeme(): String
}

class SentenceWithExpressionNode {
  -expressionNode: ExpressionNode
  -finalToken: Token
  --
  +SentenceWithExpressionNode(expressionNode: ExpressionNode)
  +getExpressionNode(): ExpressionNode
  +check(): void
  +isAssign(): boolean
  +getLine(): int
  +getLexeme(): String
  +setFinalToken(finalToken: Token): void
  +getFinalToken(): Token
}

class VarLocalNode {
  -type: Type
  -id: String
  -value: ExpressionNode
  -token: Token
  -assignToken: Token
  --
  +VarLocalNode(type: Type, token: Token)
  +VarLocalNode(token: Token, value: ExpressionNode, assignToken: Token)
  +getLexeme(): String
  +getLine(): int
  +getType(): Type
  +getId(): String
  +isAssign(): boolean
  +check(): void
  -checkNoParentBlocksContainVar(): void
}

class WhileNode {
  -condition: ExpressionNode
  -body: SentenceNode
  --
  +WhileNode(condition: ExpressionNode, body: SentenceNode)
  +check(): void
  +setBody(body: SentenceNode): void
  +getBody(): SentenceNode
  +getCondition(): ExpressionNode
}

ChainedCallNode --|> ChainingNode
ChainedCallNode *-- ChainingNode
ChainedCallNode o-- ExpressionNode
ChainedVarNode --|> ChainingNode
ChainedVarNode *-- ChainingNode
AssignNode --|> ExpressionNode
AssignNode *-- ExpressionNode
BinaryExpNode --|> CompExpNode
BinaryExpNode *-- ExpressionNode
CompExpNode --|> ExpressionNode
NullExpressionNode --|> ExpressionNode
OperandNode --|> ExpressionNode
OperandNode ..> ChainingNode
UnaryExpNode --|> CompExpNode
UnaryExpNode *-- OperandNode
BooleanLiteralNode --|> LiteralNode
CharLiteralNode --|> LiteralNode
IntLiteralNode --|> LiteralNode
LiteralNode --|> OperandNode
LiteralNode ..> ChainingNode
NullLiteralNode --|> LiteralNode
StringLiteralNode --|> LiteralNode
ConstructorCallNode --|> ReferenceNode
ConstructorCallNode *-- ChainingNode
ConstructorCallNode o-- ExpressionNode
MethodCallNode --|> ReferenceNode
MethodCallNode *-- ChainingNode
MethodCallNode o-- ExpressionNode
ParentizedExpressionNode --|> ReferenceNode
ParentizedExpressionNode *-- ExpressionNode
ParentizedExpressionNode *-- ChainingNode
ReferenceNode --|> OperandNode
ReferenceNode ..> ChainingNode
StaticMethodCallNode --|> ReferenceNode
StaticMethodCallNode *-- ChainingNode
StaticMethodCallNode o-- ExpressionNode
ThisReferenceNode --|> ReferenceNode
ThisReferenceNode *-- ChainingNode
ToyReferenceNode --|> ReferenceNode
ToyReferenceNode ..> ChainingNode
VarCallNode --|> ReferenceNode
VarCallNode *-- ChainingNode
BlockNode --|> SentenceNode
BlockNode o-- SentenceNode
BlockNode o-- VarLocalNode
BlockNode *-- BlockNode
EmptySentenceNode --|> SentenceNode
ForStandardNode --|> SentenceNode
ForStandardNode *-- SentenceNode
ForStandardNode *-- ExpressionNode
IfNode --|> SentenceNode
IfNode *-- ExpressionNode
IfNode *-- SentenceNode
NullBlockNode --|> BlockNode
ReturnNode --|> SentenceWithExpressionNode
ReturnNode *-- ExpressionNode
SentenceWithExpressionNode --|> SentenceNode
SentenceWithExpressionNode *-- ExpressionNode
VarLocalNode --|> SentenceNode
VarLocalNode *-- ExpressionNode
WhileNode --|> SentenceNode
WhileNode *-- ExpressionNode
WhileNode *-- SentenceNode
@enduml