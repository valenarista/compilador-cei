' Generated by UML Generator
' Encoded: xHfTJzmuy9rVaSSii5MVLxsg1L4T4by2sZwRnCjQP9DLuaMblVQttzXE7DippeQbSDpfNlZ8ZEVRuvcnFpIIrNAzB7QQEr6kMCsMILQmflaePIrkrf8VPrLv9RxpvEtEGkGyoKIT5NndHsCbXmicIfuVig8ugm3wOoT9fhAwu-KikLQ_rFzBBXTLViQMV9PS0TdoLdsjLb9K9Iiq2VWsIxg_52M5mUhR4z78MQ9-lZlwjgfvqy0Q1N-l43AMBNX-gidF4lEx_ww40chN3olWgtugq1H-x0LIfwx0-maMTw8MYUPynMjMvb-5NAYbwMIMt5HLmLbfu5zOBTXDmGD0m-L7eqbQHDM19VULKDBltNAf9L5aEXkgZ-U1mHGyC9dY1MWM8tF0FhB33soLtQKWpRserarlhecrsbvPoOjQB8KKzxmrQvg5vWr96dySVGDjUPbnl80ozNxYEcFYU1LCK8Bz9JzKBkkPJHUiSHogl7F9vRek0pTuoqLpmkVoIYYpj3YE-4OiGmMyMgmzb_uCWX_S7e_zpL5-3yk3hS6wpJTBx3uCWxVb6iHkGEnfWHinUCoIv_EF4C-t9MNHvudBwIFZSgf9MfE2PqKkv4Dy2RYQtJIoPfbC79-ticgFjsBgdsZVl9JfaSbjZ1gNzF5Pm8fPuYSVzRqMjmiI40QqnEcqvv5IvFSJadYmqtjJElPZDMXQpgjwoKgfFZQQWvj2D6tFSvuPvGbi5aLIbB9Bhe3cCb58_1jVwezs4u9lZ5x8PR_3fSFvX_I-TUc1A5dz0CRilLefaMHLEtugBFs8isD0xLAFHngZjPy4Z5jtKBWJUugP5U7frjb3VKT2AOJBZZADyHon0rnu9dbkLWUw-X5qoPjrOK9h40-7uul7tXRf1CAYGtNz5ykHrNBLXoU6-yupMJGgElBhSnlnwRO25X1veF8w0qEHVhgIJ8gC0C51USPvtboU7fscD_6yVhOkYl-s7N7SjFnwPSbAEIWrglxlQAMnhR-iDpwFoSYL4N_cwX4vKLrwASgn5A49lOp2eYAXnL5VVUcUvmXzhksnEImxBnmt1-PRAkdytoCUbt8O2RGuRixuBLEbVXf3K6HUHxfkomYpvaH8m1ZetaqzW91JLBt5-jOmMBRFHCDr4MpkUfms0URhKmLYPPmcFk9hKYJ8tQ4wGy6_MRgjSlpJJx4n3PSwcCVvBi1yVL5eyCOfWt1VONxm3vsuGXgT65S-OL9fqWuM81ZV8CwJCUUbCs0S5CIVCNPB9b6fenuxxCJqpRzfcuwQ-hneMRf56nvDNJREpCHoov7uKsFCPpvkiltYyNDgvVWN1j1pLcrpKRRN6IdXApiCjw5smMfUIl6TvqGlEENs6pNdsJoP9XDzZ6KQvpPcqlVgKyLsam1o1qJpHr0pNV8vhzNLIJXiVehTdDDTzLXKijeS6Ph2DPdJmgyRqrRPzNFM5CaV2HnstAajiAGf4g5BRzUROitS0hX4-uk0KKIV7BKZKkTsEVcP4z-ujXmxTCIP6Zag7Z5o6poJhnUYmTlfDrH-Ea0HzL5btVyvCEul00uNKCIjwMO_ELH7t9l6gfSl1jStxnOTwOjFP4LpeHvuSEZH4EIaobW1cY60lItz1uPNLjpmohz3wAIEmQtmKGAj536ulNIANCKLLNRN1sa3bP5A0KsRgw_Q_-rP1s6cHJvbAuLItl7yJzOiuDzttVE7BosASpusakV7fMwweBI2uai-w7zSw75v3wl06xF4_gdWArskQJbdlRZwWf0rihFV-NmE0Qp33WxVj_tOhrkGwXt1yhnJAUrqXRXqjFItVGTfx4aNMgJTJvrH31vXbj0gQhzTzAgbj9g-D2x-n3U68cU5rOVke2iTkc2IJhQqy-xCS-8soTgcXd4tmaVBbNnm9TJX-8kitn6kSIt-7A_PNNN8AOodfPNoKrL30L7chEwlSAQG6AM0ykkx7fxxmQHFvAg4oYpImgnNEPFa9VPDbJzWOje0WHZfa0HmTCVuxoSqTzfK45y785AAvSApttbldK7jQHrvqV034lAZqUNRpwHWDxmuhDO0hl6UD_pJ0SKnu_s4PhkjCKmKQQG9KaJVpBViQ33zJaonEohpvhXituUH_54feiQqVfxVypwbX99siU7ajUJsHK7Va73Fm9IlvmBwiR2rMlN78_Yoood6YptZT9Xwr4MVBCiKSNzq4XXm2wJ9R5seirOT1OKvYfpa4JJ5ACrXuIFbqTZi-sl3LBmLG1LPmrENHpcpNqOyM8tp7EDTyvB5NJJyWkOtsV5nGUHWHbj09sfwjRjdcW28jHBsB6vx2S_08dURY7lrsdFCEpYcJHDwiUeBARVhi08u5yd4LCp731eKGgxz14in6TwKzZKh-SPgr4t_SJwg6md3oOnTpYgd35Ft6X9wexRl634ZyBD3stUPRuxfqPxzkX05VzAnElBmj8mUTtu-spbvs4aHSpcTwS9d_TFfN-_zbZh4s9rEXn4gG0W42DvFHvbq28Y7yxXLBmxeE-1TpDr_HccOzm_N0Z2ntdtbHd4dNcXHQEwZfatmDsy20tqULE5pg87xj8Tu_g49E1zsmXSL225ufu3W2EXAu0AHPk4rEYADBwUn-CI5hqRoPdKa6Wvd0ea8wM2SJd0BC12Z04xmY5xw4DoYkBkFe8jaz2UfoB4-6BcMl7WWP2Vna2ma5c4rF04cM68anC-TJ18KN31QsxSHUgMNhtkO4du0v1O93aWnwqSQU2A0EORz-6QCtL0o2Y6mUzlEOk8j8Bu4SVCxCKsnrzZfj3nUk6HsKGdk0_KzLc80cI3jbQAOc0ScblTL35xRmmON8fj-u6M-NXP_0m
' URL: http://www.plantuml.com/plantuml/uml/xHfTJzmuy9rVaSSii5MVLxsg1L4T4by2sZwRnCjQP9DLuaMblVQttzXE7DippeQbSDpfNlZ8ZEVRuvcnFpIIrNAzB7QQEr6kMCsMILQmflaePIrkrf8VPrLv9RxpvEtEGkGyoKIT5NndHsCbXmicIfuVig8ugm3wOoT9fhAwu-KikLQ_rFzBBXTLViQMV9PS0TdoLdsjLb9K9Iiq2VWsIxg_52M5mUhR4z78MQ9-lZlwjgfvqy0Q1N-l43AMBNX-gidF4lEx_ww40chN3olWgtugq1H-x0LIfwx0-maMTw8MYUPynMjMvb-5NAYbwMIMt5HLmLbfu5zOBTXDmGD0m-L7eqbQHDM19VULKDBltNAf9L5aEXkgZ-U1mHGyC9dY1MWM8tF0FhB33soLtQKWpRserarlhecrsbvPoOjQB8KKzxmrQvg5vWr96dySVGDjUPbnl80ozNxYEcFYU1LCK8Bz9JzKBkkPJHUiSHogl7F9vRek0pTuoqLpmkVoIYYpj3YE-4OiGmMyMgmzb_uCWX_S7e_zpL5-3yk3hS6wpJTBx3uCWxVb6iHkGEnfWHinUCoIv_EF4C-t9MNHvudBwIFZSgf9MfE2PqKkv4Dy2RYQtJIoPfbC79-ticgFjsBgdsZVl9JfaSbjZ1gNzF5Pm8fPuYSVzRqMjmiI40QqnEcqvv5IvFSJadYmqtjJElPZDMXQpgjwoKgfFZQQWvj2D6tFSvuPvGbi5aLIbB9Bhe3cCb58_1jVwezs4u9lZ5x8PR_3fSFvX_I-TUc1A5dz0CRilLefaMHLEtugBFs8isD0xLAFHngZjPy4Z5jtKBWJUugP5U7frjb3VKT2AOJBZZADyHon0rnu9dbkLWUw-X5qoPjrOK9h40-7uul7tXRf1CAYGtNz5ykHrNBLXoU6-yupMJGgElBhSnlnwRO25X1veF8w0qEHVhgIJ8gC0C51USPvtboU7fscD_6yVhOkYl-s7N7SjFnwPSbAEIWrglxlQAMnhR-iDpwFoSYL4N_cwX4vKLrwASgn5A49lOp2eYAXnL5VVUcUvmXzhksnEImxBnmt1-PRAkdytoCUbt8O2RGuRixuBLEbVXf3K6HUHxfkomYpvaH8m1ZetaqzW91JLBt5-jOmMBRFHCDr4MpkUfms0URhKmLYPPmcFk9hKYJ8tQ4wGy6_MRgjSlpJJx4n3PSwcCVvBi1yVL5eyCOfWt1VONxm3vsuGXgT65S-OL9fqWuM81ZV8CwJCUUbCs0S5CIVCNPB9b6fenuxxCJqpRzfcuwQ-hneMRf56nvDNJREpCHoov7uKsFCPpvkiltYyNDgvVWN1j1pLcrpKRRN6IdXApiCjw5smMfUIl6TvqGlEENs6pNdsJoP9XDzZ6KQvpPcqlVgKyLsam1o1qJpHr0pNV8vhzNLIJXiVehTdDDTzLXKijeS6Ph2DPdJmgyRqrRPzNFM5CaV2HnstAajiAGf4g5BRzUROitS0hX4-uk0KKIV7BKZKkTsEVcP4z-ujXmxTCIP6Zag7Z5o6poJhnUYmTlfDrH-Ea0HzL5btVyvCEul00uNKCIjwMO_ELH7t9l6gfSl1jStxnOTwOjFP4LpeHvuSEZH4EIaobW1cY60lItz1uPNLjpmohz3wAIEmQtmKGAj536ulNIANCKLLNRN1sa3bP5A0KsRgw_Q_-rP1s6cHJvbAuLItl7yJzOiuDzttVE7BosASpusakV7fMwweBI2uai-w7zSw75v3wl06xF4_gdWArskQJbdlRZwWf0rihFV-NmE0Qp33WxVj_tOhrkGwXt1yhnJAUrqXRXqjFItVGTfx4aNMgJTJvrH31vXbj0gQhzTzAgbj9g-D2x-n3U68cU5rOVke2iTkc2IJhQqy-xCS-8soTgcXd4tmaVBbNnm9TJX-8kitn6kSIt-7A_PNNN8AOodfPNoKrL30L7chEwlSAQG6AM0ykkx7fxxmQHFvAg4oYpImgnNEPFa9VPDbJzWOje0WHZfa0HmTCVuxoSqTzfK45y785AAvSApttbldK7jQHrvqV034lAZqUNRpwHWDxmuhDO0hl6UD_pJ0SKnu_s4PhkjCKmKQQG9KaJVpBViQ33zJaonEohpvhXituUH_54feiQqVfxVypwbX99siU7ajUJsHK7Va73Fm9IlvmBwiR2rMlN78_Yoood6YptZT9Xwr4MVBCiKSNzq4XXm2wJ9R5seirOT1OKvYfpa4JJ5ACrXuIFbqTZi-sl3LBmLG1LPmrENHpcpNqOyM8tp7EDTyvB5NJJyWkOtsV5nGUHWHbj09sfwjRjdcW28jHBsB6vx2S_08dURY7lrsdFCEpYcJHDwiUeBARVhi08u5yd4LCp731eKGgxz14in6TwKzZKh-SPgr4t_SJwg6md3oOnTpYgd35Ft6X9wexRl634ZyBD3stUPRuxfqPxzkX05VzAnElBmj8mUTtu-spbvs4aHSpcTwS9d_TFfN-_zbZh4s9rEXn4gG0W42DvFHvbq28Y7yxXLBmxeE-1TpDr_HccOzm_N0Z2ntdtbHd4dNcXHQEwZfatmDsy20tqULE5pg87xj8Tu_g49E1zsmXSL225ufu3W2EXAu0AHPk4rEYADBwUn-CI5hqRoPdKa6Wvd0ea8wM2SJd0BC12Z04xmY5xw4DoYkBkFe8jaz2UfoB4-6BcMl7WWP2Vna2ma5c4rF04cM68anC-TJ18KN31QsxSHUgMNhtkO4du0v1O93aWnwqSQU2A0EORz-6QCtL0o2Y6mUzlEOk8j8Bu4SVCxCKsnrzZfj3nUk6HsKGdk0_KzLc80cI3jbQAOc0ScblTL35xRmmON8fj-u6M-NXP_0m
' Generated on: 2025-11-21T12:47:02.344540600

@startuml
skinparam classAttributeIconSize 0
hide circle

class ChainedCallNode {
  -token: Token
  -methodName: String
  -optionalChaining: ChainingNode
  -argList: List<ExpressionNode>
  -cachedMethod: Method
  -cachedCallingType: Type
  --
  +ChainedCallNode(token: Token, methodName: String)
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +setArgList(list: List<ExpressionNode>): void
  +getToken(): Token
  +getOptionalChaining(): ChainingNode
  +setOptChaining(chainingNode: ChainingNode): void
  +check(previousType: Type): Type
  +notPrimitiveCalling(callingType: Type): void
  +checkMethodExistence(callingType: Type, methodName: String, token: Token): Method
  +generateCode(): void
  -hasChainedCallWithReturn(): boolean
  +generateCode(isLeftSide: boolean): void
  +methodReturnsValue(): boolean
}

class ChainedVarNode {
  -token: Token
  -optionalChaining: ChainingNode
  -varName: String
  -attribute: Attribute
  --
  +ChainedVarNode(token: Token, varName: String)
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +generateCode(): void
  +generateCode(isLeftSideOfAssign: boolean): void
  +setOptChaining(chainingNode: ChainingNode): void
  +check(previousType: Type): Type
  -notPrimitiveCalling(callingType: Type): void
  -checkAttributeValidity(callingType: Type): void
}

abstract class ChainingNode {
  +check(check: Type): Type
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
}

class AssignNode {
  -left: ExpressionNode
  -right: ExpressionNode
  -token: Token
  -type: Type
  --
  +AssignNode(left: ExpressionNode, right: ExpressionNode, token: Token)
  +check(): Type
  +areConformantTypes(leftType: Type, rightType: Type): boolean
  +getLine(): int
  +getType(): Type
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +generateCode(isLeftSide: boolean): void
  +generateCode(): void
}

class BinaryExpNode {
  -operator: Token
  -leftSide: ExpressionNode
  -rightSide: ExpressionNode
  --
  +BinaryExpNode(leftSide: ExpressionNode, operator: Token, rightSide: ExpressionNode)
  +getOperator(): Token
  +getLeftSide(): ExpressionNode
  +getRightSide(): ExpressionNode
  +check(): Type
  +areConformantTypes(leftType: Type, rightType: Type): boolean
  +getExpectedTypes(operator: Token): Type
  +getResultType(operator: Token): Type
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  -generateOperator(): void
}

abstract class CompExpNode {
}

abstract class ExpressionNode {
  +isVariable(): boolean
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  +isConstructorCall(): boolean
  +isStaticCall(): boolean
  +setNeedsRMEM(b: boolean): void
}

class NullExpressionNode {
  +isVariable(): boolean
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
}

abstract class OperandNode {
  +getToken(): Token
  +setOptChaining(optChaining: ChainingNode): void
  +isConstructorCall(): boolean
  +isStaticCall(): boolean
}

class UnaryExpNode {
  -operator: Token
  -operand: OperandNode
  -type: Type
  --
  +UnaryExpNode(operator: Token, operand: OperandNode)
  +UnaryExpNode(operand: OperandNode)
  +check(): Type
  +getOperand(): OperandNode
  +getLine(): int
  +getType(): Type
  +getLexeme(): String
  +isAssign(): boolean
  +isConstructorCall(): boolean
  +isStaticCall(): boolean
  +setNeedsRMEM(b: boolean): void
  +isOperandWithCall(): boolean
  -operandIsBoolean(type: Type): boolean
  -operandIsInt(type: Type): boolean
  -operatorIsNegation(): boolean
  -operatorIsInt(): boolean
  +isVariable(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  -generateOperator(): void
}

class BooleanLiteralNode {
  -token: Token
  --
  +BooleanLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +generateCode(): void
}

class CharLiteralNode {
  -token: Token
  --
  +CharLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +generateCode(): void
}

class IntLiteralNode {
  -token: Token
  --
  +IntLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +generateCode(): void
}

abstract class LiteralNode {
  +isVariable(): boolean
  +getType(): Type
  +check(): Type
  +setOptChaining(optChaining: ChainingNode): void
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +generateCode(isLeftSide: boolean): void
}

class NullLiteralNode {
  -token: Token
  --
  +NullLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +generateCode(): void
}

class StringLiteralNode {
  -token: Token
  --
  +StringLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +generateCode(): void
}

class ConstructorCallNode {
  -token: Token
  -className: String
  -optChaining: ChainingNode
  -argList: List<ExpressionNode>
  --
  +ConstructorCallNode(token: Token, className: String)
  +isConstructorCall(): boolean
  +setArgList(argList: List<ExpressionNode>): void
  +getArgList(): List<ExpressionNode>
  +getToken(): Token
  +getClassName(): String
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +generateCode(isLeftSide: boolean): void
  +generateCode(): void
  +isVariable(): boolean
}

class MethodCallNode {
  -token: Token
  -methodName: String
  -optChaining: ChainingNode
  -argList: List<ExpressionNode>
  --
  +MethodCallNode(token: Token, methodName: String)
  +setArgList(argList: List<ExpressionNode>): void
  +getArgList(): List<ExpressionNode>
  +getToken(): Token
  +getMethodName(): String
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  -findMethod(methodName: String): Method
}

class ParentizedExpressionNode {
  -expression: ExpressionNode
  -optionalChaining: ChainingNode
  -token: Token
  --
  +ParentizedExpressionNode(expression: ExpressionNode, token: Token)
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  +getToken(): Token
  +isVariable(): boolean
}

abstract class ReferenceNode {
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
}

class StaticMethodCallNode {
  -optionalChaining: ChainingNode
  -classToken: Token
  -methodToken: Token
  -argList: List<ExpressionNode>
  -needsRMEM: boolean = true
  --
  +StaticMethodCallNode(classToken: Token, methodToken: Token)
  +check(): Type
  -checkStaticMethodValidity(classToken: Token, methodToken: Token): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getArgList(): List<ExpressionNode>
  +setArgList(argList: List<ExpressionNode>): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isStaticCall(): boolean
  +setNeedsRMEM(needsRMEM: boolean): void
  +generateCode(): void
  +getToken(): Token
  +generateCode(isLeftSide: boolean): void
  +isVariable(): boolean
}

class ThisReferenceNode {
  -token: Token
  -className: String
  -optChaining: ChainingNode
  --
  +ThisReferenceNode(token: Token, className: String)
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  +getToken(): Token
  +isVariable(): boolean
}

class VarCallNode {
  -token: Token
  -varName: String
  -optChaining: ChainingNode
  --
  +VarCallNode(token: Token, varName: String)
  +getToken(): Token
  +getVarName(): String
  +setOptChaining(optChaining: ChainingNode): void
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isParameter(): boolean
  +isLocalVar(): boolean
  +isAttribute(): boolean
  +isVariable(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  -generateParameterCode(): void
  -generateLocalVarCode(): void
  -generateAttributeCode(): void
  -generateLeftSideCode(): void
  -generateRightSideCode(): void
}

class BlockNode {
  -sentences: List<SentenceNode>
  -varLocalMap: LinkedHashMap<String, VarLocalNode>
  -nestedInClass: EntityClass
  -nestedInInvocable: Invocable
  -parentBlock: BlockNode
  -lastLocalVarOffset: int = 0
  --
  +BlockNode()
  +addSentence(sentence: SentenceNode): void
  +getSentences(): List<SentenceNode>
  +getVarLocalMap(): LinkedHashMap<String,VarLocalNode>
  +setParentBlock(parentBlock: BlockNode): void
  +getParentBlock(): BlockNode
  +setSentencesList(sentences: List<SentenceNode>): void
  +addVarLocal(varLocal: VarLocalNode): void
  +getLine(): int
  +getLexeme(): String
  +check(): void
  +generateCode(): void
}

class EmptySentenceNode {
  ~token: Token
  --
  +EmptySentenceNode()
  +EmptySentenceNode(token: Token)
  +check(): void
  +getLexeme(): String
  +getLine(): int
}

class ForStandardNode {
  -initialization: SentenceNode
  -condition: ExpressionNode
  -update: ExpressionNode
  -body: SentenceNode
  --
  +ForStandardNode(initialization: SentenceNode, condition: ExpressionNode, update: ExpressionNode)
  +check(): void
  +setBody(body: SentenceNode): void
}

class IfNode {
  -condition: ExpressionNode
  -body: SentenceNode
  -elseBody: SentenceNode
  -{static} labelCounter: int = 0
  --
  +IfNode(condition: ExpressionNode, body: SentenceNode, elseBody: SentenceNode)
  +check(): void
  +setBody(body: SentenceNode): void
  +getBody(): SentenceNode
  +getElseBody(): SentenceNode
  +generateCode(): void
  -bodyEndsInReturn(body: SentenceNode): boolean
}

class NullBlockNode {
  +NullBlockNode()
  +check(): void
}

class ReturnNode {
  -expectedType: Type
  -expressionNode: ExpressionNode
  -finalToken: Token
  -parameterCount: int
  --
  +ReturnNode(expressionNode: ExpressionNode)
  +check(): void
  +setFinalToken(finalToken: Token): void
  +getLexeme(): String
  +getLine(): int
  +generateCode(): void
  -calculateRetValOffset(): int
}

abstract class SentenceNode {
  +check(): void
  +isAssign(): boolean
  +getLine(): int
  +getLexeme(): String
  ~generateCode(): void
}

class SentenceWithExpressionNode {
  -expressionNode: ExpressionNode
  -finalToken: Token
  -expressionType: Type
  --
  +SentenceWithExpressionNode(expressionNode: ExpressionNode)
  +getExpressionNode(): ExpressionNode
  +check(): void
  +isAssign(): boolean
  +getLine(): int
  +getLexeme(): String
  +setFinalToken(finalToken: Token): void
  +getFinalToken(): Token
  +generateCode(): void
  -expressionReturnsVoid(): boolean
}

class VarLocalNode {
  -type: Type
  -id: String
  -value: ExpressionNode
  -token: Token
  -assignToken: Token
  -offset: int
  --
  +VarLocalNode(type: Type, token: Token)
  +VarLocalNode(token: Token, value: ExpressionNode, assignToken: Token)
  +getLexeme(): String
  +getValue(): ExpressionNode
  +getLine(): int
  +getType(): Type
  +getId(): String
  +isAssign(): boolean
  +check(): void
  -checkNoParentBlocksContainVar(): void
  +generateCode(): void
  +getOffset(): int
  +setOffset(offset: int): void
}

class WhileNode {
  -condition: ExpressionNode
  -body: SentenceNode
  -{static} labelCounter: int = 0
  --
  +WhileNode(condition: ExpressionNode, body: SentenceNode)
  +check(): void
  +setBody(body: SentenceNode): void
  +getBody(): SentenceNode
  +getCondition(): ExpressionNode
  +generateCode(): void
}

ChainedCallNode --|> ChainingNode
ChainedCallNode *-- ChainingNode
ChainedCallNode o-- ExpressionNode
ChainedVarNode --|> ChainingNode
ChainedVarNode *-- ChainingNode
AssignNode --|> ExpressionNode
AssignNode *-- ExpressionNode
BinaryExpNode --|> CompExpNode
BinaryExpNode *-- ExpressionNode
CompExpNode --|> ExpressionNode
NullExpressionNode --|> ExpressionNode
OperandNode --|> ExpressionNode
OperandNode ..> ChainingNode
UnaryExpNode --|> CompExpNode
UnaryExpNode *-- OperandNode
BooleanLiteralNode --|> LiteralNode
CharLiteralNode --|> LiteralNode
IntLiteralNode --|> LiteralNode
LiteralNode --|> OperandNode
LiteralNode ..> ChainingNode
NullLiteralNode --|> LiteralNode
StringLiteralNode --|> LiteralNode
ConstructorCallNode --|> ReferenceNode
ConstructorCallNode *-- ChainingNode
ConstructorCallNode o-- ExpressionNode
MethodCallNode --|> ReferenceNode
MethodCallNode *-- ChainingNode
MethodCallNode o-- ExpressionNode
ParentizedExpressionNode --|> ReferenceNode
ParentizedExpressionNode *-- ExpressionNode
ParentizedExpressionNode *-- ChainingNode
ReferenceNode --|> OperandNode
ReferenceNode ..> ChainingNode
StaticMethodCallNode --|> ReferenceNode
StaticMethodCallNode *-- ChainingNode
StaticMethodCallNode o-- ExpressionNode
ThisReferenceNode --|> ReferenceNode
ThisReferenceNode *-- ChainingNode
VarCallNode --|> ReferenceNode
VarCallNode *-- ChainingNode
BlockNode --|> SentenceNode
BlockNode o-- SentenceNode
BlockNode o-- VarLocalNode
BlockNode *-- BlockNode
EmptySentenceNode --|> SentenceNode
ForStandardNode --|> SentenceNode
ForStandardNode *-- SentenceNode
ForStandardNode *-- ExpressionNode
IfNode --|> SentenceNode
IfNode *-- ExpressionNode
IfNode *-- SentenceNode
NullBlockNode --|> BlockNode
ReturnNode --|> SentenceWithExpressionNode
ReturnNode *-- ExpressionNode
SentenceWithExpressionNode --|> SentenceNode
SentenceWithExpressionNode *-- ExpressionNode
VarLocalNode --|> SentenceNode
VarLocalNode *-- ExpressionNode
WhileNode --|> SentenceNode
WhileNode *-- ExpressionNode
WhileNode *-- SentenceNode
@enduml