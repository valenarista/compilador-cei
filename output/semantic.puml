' Generated by UML Generator
' Encoded: xHnTSzisyZs_WezKOsNwhEbvBd7JgsVyaR7Tz9aY8GiDHUf8oetRAt_xuOl0Oh6WADdE-MxknOcuYyLYTx4V-FfxssLDjzkKRzellDfcJRP9yZ9hs_TTr_3bhcFdULtTyZzOylsRDIzOalCcBzcRDmehELjdl6B5MLQMLxM0_lacIUPT_OLLY-HE_YD_RrYthekhRCCMoQqWMztBh_MsutMLbOg4-BP8Xlz9IX8ZQ-ulUDij4ldtXuzVjmrhMz56maybGfxbQrPSAlABHF_hlakc1BMxnwteL_wLeBduynPndKA6JvAGtPbinDlhBMkoglYLTslPD9qjacLTboohDFnprl1iMJ84Q5dtNeyaBQF34KqUQYwvVtlFEiM993F8K7wyHWAJS2GosPT0inWv0Fl8e3yXg_nBAhXvuFMkTUAQMQczhUhkKyCtlECFp8WrpR5uCKcjZuzVnMXPbREm0INgamGgOmQqAaHG2Vbtx4ogp7KsNsSjKAZKpWthTas5rE0rv-q5MtMtN8h5u03sDLkQYj1gkVDK-XSoVg7skEtlj_87qHnDZMoOV8l4paDilAPNPBk8sDCCDoBmc2IlL--5FTzNb4HVnYxd1zhbN96q8XMQvGNl7kDDXAgpPTirMTubGEU6LwLnmwRw6yoRRoNwGEJMHhLAd7sMeiKYyPsF_Dxm-pK9m0RTXUxKzP5Iv4yIaZYQwKwKG7vP8qPQhUfcarMT_DYg7g0BKRGzpNbYx2x4P94aUTKDpbMWmKua4llADkgZdOH2DtfSWSgUGwNZ_eVKlbNf1rvbpQCGfjDgBLdgwWRegRJq8ygE0PLAlJxI6AsJ17Lir47XpcmKqormT1la8Ry7J4c4cu4oZV4IjYDwONd72jqQZTMte1lMxafjMgDueJb-Szixmfq8inXGeVvYFhBUR9rvXd1VUTgBHbaFzFhIGdowh4GNmlB4a7Uv41IffzikwtXEW4IWl6AiQ6ykFrwcoxXVlzgLvV-s74ExCVsvmPAPCaerQlV_QAPnhBwiDdwPuf5hpVu2ZYCIKI6zDF2n5A4PtOp2eYp1uCYlFdSl4q9VQdhiDyj12-Vj1_qjxMZ_xn3FgsuSIOpYlBrYzvbCzTCOWYJpEjorIIDqcmlU2OoHwbtd0m5o6cHliReL6ylndcWyBnAJkvas6eJv-eOYR6NQI7p4rpGGvBlnSCQCVpztH_dufqUnAGMN3CpJT8SmNvyLQhnfWmbmNw5_y8DEV40AdLYkVC9AfNOx8GDe-IReUJObNe85nb56_3N6eSaiodLKOsS3cxxuzqtJIQi-tpGjFQ8CZxekQsTwnVB89V6dsfZV-RILxMzkFvUMZ_z20th9h6t5AxETaHAwielXrjG-PGshElu7AuXQSCxiDsgTP__ADEdeOrscyTwchFIzUbTnt4e0EGEY_WFbJ3TinHgvTO8NcvyYDn3TPOr5EQlzbg4et94-3N_TwxQgePwpeaZ-beXWnq1k4NAQ1YmCxkrkdwtfNG18r6q4J2BwPAkTu3gFyyalxFYcbUMXGYV4r4YeE639RJGctwrv6qwdPyZyb846r2UbTV_tWN5z2U1u0aNickxN4w0wOTyqbhryrhY-U8-eIB_vYYnlFya37apKQ07aeiwpKemi0DZTql_0ufLb5s_v3mW3rp6uPJvAm70HWzjDfyXMN5ddNvoHjY8paYwWDRxwrlosiKwOcMBvCjjAbEeBAtxEshNu-SDm_E6pGG7niUrOSLwfeakaLYBvwXxL3mWzhnv4Aw6DHMB_A-5RbQufFXUENRL1cBNT8B_hrKeOi38x4No_Tyj-GuDKpOYiA8OXfSDOXLs2KVhJVe2qDj9XYPZvD0X5un5YmLAHy-sJ6rfA3zFd1kBFV658SfPP5NH7LGde2f4ClAM3TXUU4eznrjOrJDiH_hZPTe-GGsMEFPc_1xXQjU7dUCuEXqEkmdYZj5p-L3SYWQYAh75RE7FX63ikqgy_rEAvRqmg8jULoCmY9SnkMsGTkOczh8l7a9WI068Z7UD0XEvO_oS9tJijAc5V7mHBQSXNkFQxSj8P7JqzHbQsx0C9-RDLwTjVIPajMNbMxmIu2UUyxZyT6NZOyKb2TtkiCBGLAQHPC12rCs-wey7qEJ7PtSUgQCyhSpwCx3z8HUGohU_dttgVKcAGjh7koIl9xOa2Lv0mJy2KhbTSr6EujDgwy2XqEVWKhKNNSJfEFQgYdsoNQT3xmKvWH2t2JUQxKiPQ6GfA7Og0yq15SU3cGkOZwT5KxzllMHKt3CWaQtpLvI1bkcR4WTLudrEqgq-om4RZ9sYUIOw76H70Z9Q0m6hSi8TZcW8GAoLiB3QrX2TWNi0Yua6Uzfno3YvJei5Qh5qY1QiEom3OI2PMnNnCLA0GV9qa8HUpyKbfJxEIPwmcxVIV5vEg4MnEUjdbgWPfcDpNw4HjPEgE2Mi4ldSmTPV-1aGVpDbVrxnaJmgh4uEdxUYm-FbYSV9iu2AcyZ5FPwidawe5Qtl-H7hWBL_oKbGdNfqUcK_KJ76rfj-Nc2fWsWJz32OVLkMJJ5gKnRjboVFGpNssFU4JHdeQaOFpTJCotqJbbdtWhFgH2N4tML6d_kB0FtUiDYhbMViy4m5i9CQKIghHfXgY7i8LgwtIJoqcMA_qeKkY4Ar_5qP8LxTgia7tZFTH0qEXZKFE95NtBKShHBesZ5bMn3fqfQbbOEjUJmg4MOeoqgtDM64ld6pHMNehiZGYFI-Ca_OzBEUQ_QPWTGV5qwSQx8LKvRJjUYvzwohBcLlAq0KjfOb-Wcxxc6xxG1Fzs23xiK7s-nNVHwsc3ms0L7vFAxCVKsRFuycHnjUkuBdcUEXI6fMY-NdjfYxuYhDcd-TPPwskAy6XkWEzYCWLXSHufpD5_tYU7uLeVsE4YbqD7jL9WiOKyqR7qfiTwYcEcVbJN6Mh2WeWqpGYOj16w16r2S8jxNwD0OHi_cm0s49G08vwwOdfmWHdVcCrXrBbIwF0u2gVyzypRAvFShFHn9bmlwCPGoJB8EC22aZBtrZUnICIFBoWnJWjlQGIHZSJuWdZ4xF3KMqSB4AOYELYmZCb6XtT0W7qQxMZo3FmYM-sfQZhgiwiLbg0zXMvOB21OMN8g0cVRhDj5PhQjMZwEolUJswXTyO9DErN50wln1XuDrpI7KTkMC5MycxZvI6K1LDxMSrTnhY0EV00gqikrt8BBsnkBJ_mPC8gAri6Xg_rsv8eJleZMFFFTnUnDDUPI63WeRvr4Gb6WwQfPjXmSikwS1PVOWpSXDgig-hksatvGr964PwiY4Dc08pGn4INsAkY-aUM5SedqfjMClHc-LhldZdwU2tZN5jS9dU__5Koiq8PX5crfXK9lkYU0Dze8U95b46TZRUI0fIibrCWrBe8xoJPS7WC8fefvCfkwk8nqM0VOIKk5tXj5FGRd2HCtWqN9dyvIcWGRuGCHjTVZ-vJdhOb39dB-nkwAWaJbucXvT9DMPmGEAyh8SYPURxCdP-aK9s3L2jroFjERt0OFx0Wds47An5-De7C6xR8PATQdiJTOtGI1V8HS_b-2pYdKRH5Y5xSJSamZ2qHjS7WCzx8ZOzc6WyobRsRMaI3xvzvq-soycuugG7edPtVo9Szg4Ma5cKvLYSq-DABXQYRA_RLYomW5tALFaWKTJOq7gtw8wFLdlAUyhPxY_vmII9SLOZF_ZuoFNf_dl-MFMJlTXqltqKdS1-PyOSszUT-jBMVOGK-R7gxKU_Hny9hJmVIdeowFUdK-wXJx-DfL1_FMle3ifO-Cc_xiTdKxvc98vDDBp5DzRVzVd_R7-nl-wd-jYVTK1_nW7teoU0zEkDV8YLcM67DwKBgsOkTW-gNoMNSF5RDpA7PacN8GqUN8MwAJ2n1NgREsBCi4YzxIAV-NBL7BFgEniIdpEBHQcTVOU0ctw4flsmpE0GoPnx9ZidaRpmT9XFgrvRrXWd-CsRDprP3JKoTfoMXT7uOJqt357C-KaeVanOVM4GSM26CrFPqaKYb9DH2W3jDzBXPrZexDwUPn6VsFfSvEruPTc5WWCFNmVfyryWP7pa93DV0XkOerTBsCG3TmskA9IBo0EvE0GF4OUEtt7GawY2mRwG9gRZLmll3ofQ83Ws-Y5eL-zr2JzK9F9z2z806aBSvkDSmUTBSUdar7DOIQ-ucyEHY32ISNfCNa-LCoqLRJAdEvRZdxgeTUyWaYCNsRwNPGWeaSQlgb1FwHtKVRZBpJGMGdL9qUvZqo0-kouc69EKfk_e1W_19mGwB5ct6tAEkYCC1DA_X8eZ1yovKm0aCXZNPfGsNiP5PXUDGtaQznKZWHkw8k9DnqTiYCHGP7WsEsb3nyDp16tZW9qeemf3zR1TevRjJmlsQtJxts9UzcXMy-kL13hl6uZp6ZrcN-MaMx_wXiJop5SL6jhsfHKqi_0U980Xckx8pBeX4YKPW_of7YYyqmJJbkZbJJkysyBcXQRXYO1YurwgDlYiZ9QeZ6lYGclSCRdTBkK5tlKhZJx1vxxeuQiEleqYTwvVWD2NpuoX2yWIufHH_taFH3uvvJkuB7NssJrswdYjq1qxlYaAyj0gVax08HonbWwFjOEwOSvKIS6ukhVlIyB0DJr0YJs7f496w5KVBTX_jVUhgte768xVGdHaElmwqG_poydp-hrF_rYF6-6u-7qUe1G8wfaZHCE6J0YdFZfx5ZJ8s8CJuWd0N9n7mtRjJqElmCAlz2fu_LNoWuG7mT-7W4LGHz1_Vr6DppnqYC47JHt3SWoSJAKRHHGFRZdW6a6fEe5aIy5KzgYs4oqQUgduPbSOlM1ZmRRa0gEKRlagco88F50uqWsQqCKQmBT6RMq531BVjWaPma7jR11B5xqS5V604IpPyhYbe6w802mnVHrBjlOlj95euWGaaohaGQ9OVz305mGh22BX0S881X17hMtutJY_wu0h1NnINS0kZkDweefYMU_-TWy0aVN2aLM2Mv6iXnA19l60G91QX81BFiXm-wa0m5285t8GejWlu3W517883iX1e2RgRX8gSTsN3mQGeHa3mdX00ARi2PPyFSHM-_zsLi-4ruf17V8btFyPtU2mK0jAxkGCR4ZU0U9EWD__wfgBeHWokPtfzXVVi8AeDLkWRDjxuHS5mO2F8Xv6sp7dtti8EFJ3TYEZONQGAAJhOQCD0G-wQaMN3_nGF6s9U2IwSPKEGd2XkZG12VAl743Y3tFq3EO5T6_-xwyKSfqTScQy-G-QZ7JBuxVe17o5RxkIiIxgzywIA0TZ21zT-HXt0XWpV0ypdfzwY5kuHMGCyqA6Y2MYAOOuN336Sk7tSO6GE13ZtFphoa8xF4bo7boE5NM2OeuSXJkSOCjQNOHf-hf76SHDd8X3YKa7qqPaTXdXr-HkuTgCckBUKu86zZ3lMmC9WbXr37a1USUEGVKujp6BxgoFAJlp41dttMzkQd63CmYpstrbLx3Rblm4
' URL: http://www.plantuml.com/plantuml/uml/xHnTSzisyZs_WezKOsNwhEbvBd7JgsVyaR7Tz9aY8GiDHUf8oetRAt_xuOl0Oh6WADdE-MxknOcuYyLYTx4V-FfxssLDjzkKRzellDfcJRP9yZ9hs_TTr_3bhcFdULtTyZzOylsRDIzOalCcBzcRDmehELjdl6B5MLQMLxM0_lacIUPT_OLLY-HE_YD_RrYthekhRCCMoQqWMztBh_MsutMLbOg4-BP8Xlz9IX8ZQ-ulUDij4ldtXuzVjmrhMz56maybGfxbQrPSAlABHF_hlakc1BMxnwteL_wLeBduynPndKA6JvAGtPbinDlhBMkoglYLTslPD9qjacLTboohDFnprl1iMJ84Q5dtNeyaBQF34KqUQYwvVtlFEiM993F8K7wyHWAJS2GosPT0inWv0Fl8e3yXg_nBAhXvuFMkTUAQMQczhUhkKyCtlECFp8WrpR5uCKcjZuzVnMXPbREm0INgamGgOmQqAaHG2Vbtx4ogp7KsNsSjKAZKpWthTas5rE0rv-q5MtMtN8h5u03sDLkQYj1gkVDK-XSoVg7skEtlj_87qHnDZMoOV8l4paDilAPNPBk8sDCCDoBmc2IlL--5FTzNb4HVnYxd1zhbN96q8XMQvGNl7kDDXAgpPTirMTubGEU6LwLnmwRw6yoRRoNwGEJMHhLAd7sMeiKYyPsF_Dxm-pK9m0RTXUxKzP5Iv4yIaZYQwKwKG7vP8qPQhUfcarMT_DYg7g0BKRGzpNbYx2x4P94aUTKDpbMWmKua4llADkgZdOH2DtfSWSgUGwNZ_eVKlbNf1rvbpQCGfjDgBLdgwWRegRJq8ygE0PLAlJxI6AsJ17Lir47XpcmKqormT1la8Ry7J4c4cu4oZV4IjYDwONd72jqQZTMte1lMxafjMgDueJb-Szixmfq8inXGeVvYFhBUR9rvXd1VUTgBHbaFzFhIGdowh4GNmlB4a7Uv41IffzikwtXEW4IWl6AiQ6ykFrwcoxXVlzgLvV-s74ExCVsvmPAPCaerQlV_QAPnhBwiDdwPuf5hpVu2ZYCIKI6zDF2n5A4PtOp2eYp1uCYlFdSl4q9VQdhiDyj12-Vj1_qjxMZ_xn3FgsuSIOpYlBrYzvbCzTCOWYJpEjorIIDqcmlU2OoHwbtd0m5o6cHliReL6ylndcWyBnAJkvas6eJv-eOYR6NQI7p4rpGGvBlnSCQCVpztH_dufqUnAGMN3CpJT8SmNvyLQhnfWmbmNw5_y8DEV40AdLYkVC9AfNOx8GDe-IReUJObNe85nb56_3N6eSaiodLKOsS3cxxuzqtJIQi-tpGjFQ8CZxekQsTwnVB89V6dsfZV-RILxMzkFvUMZ_z20th9h6t5AxETaHAwielXrjG-PGshElu7AuXQSCxiDsgTP__ADEdeOrscyTwchFIzUbTnt4e0EGEY_WFbJ3TinHgvTO8NcvyYDn3TPOr5EQlzbg4et94-3N_TwxQgePwpeaZ-beXWnq1k4NAQ1YmCxkrkdwtfNG18r6q4J2BwPAkTu3gFyyalxFYcbUMXGYV4r4YeE639RJGctwrv6qwdPyZyb846r2UbTV_tWN5z2U1u0aNickxN4w0wOTyqbhryrhY-U8-eIB_vYYnlFya37apKQ07aeiwpKemi0DZTql_0ufLb5s_v3mW3rp6uPJvAm70HWzjDfyXMN5ddNvoHjY8paYwWDRxwrlosiKwOcMBvCjjAbEeBAtxEshNu-SDm_E6pGG7niUrOSLwfeakaLYBvwXxL3mWzhnv4Aw6DHMB_A-5RbQufFXUENRL1cBNT8B_hrKeOi38x4No_Tyj-GuDKpOYiA8OXfSDOXLs2KVhJVe2qDj9XYPZvD0X5un5YmLAHy-sJ6rfA3zFd1kBFV658SfPP5NH7LGde2f4ClAM3TXUU4eznrjOrJDiH_hZPTe-GGsMEFPc_1xXQjU7dUCuEXqEkmdYZj5p-L3SYWQYAh75RE7FX63ikqgy_rEAvRqmg8jULoCmY9SnkMsGTkOczh8l7a9WI068Z7UD0XEvO_oS9tJijAc5V7mHBQSXNkFQxSj8P7JqzHbQsx0C9-RDLwTjVIPajMNbMxmIu2UUyxZyT6NZOyKb2TtkiCBGLAQHPC12rCs-wey7qEJ7PtSUgQCyhSpwCx3z8HUGohU_dttgVKcAGjh7koIl9xOa2Lv0mJy2KhbTSr6EujDgwy2XqEVWKhKNNSJfEFQgYdsoNQT3xmKvWH2t2JUQxKiPQ6GfA7Og0yq15SU3cGkOZwT5KxzllMHKt3CWaQtpLvI1bkcR4WTLudrEqgq-om4RZ9sYUIOw76H70Z9Q0m6hSi8TZcW8GAoLiB3QrX2TWNi0Yua6Uzfno3YvJei5Qh5qY1QiEom3OI2PMnNnCLA0GV9qa8HUpyKbfJxEIPwmcxVIV5vEg4MnEUjdbgWPfcDpNw4HjPEgE2Mi4ldSmTPV-1aGVpDbVrxnaJmgh4uEdxUYm-FbYSV9iu2AcyZ5FPwidawe5Qtl-H7hWBL_oKbGdNfqUcK_KJ76rfj-Nc2fWsWJz32OVLkMJJ5gKnRjboVFGpNssFU4JHdeQaOFpTJCotqJbbdtWhFgH2N4tML6d_kB0FtUiDYhbMViy4m5i9CQKIghHfXgY7i8LgwtIJoqcMA_qeKkY4Ar_5qP8LxTgia7tZFTH0qEXZKFE95NtBKShHBesZ5bMn3fqfQbbOEjUJmg4MOeoqgtDM64ld6pHMNehiZGYFI-Ca_OzBEUQ_QPWTGV5qwSQx8LKvRJjUYvzwohBcLlAq0KjfOb-Wcxxc6xxG1Fzs23xiK7s-nNVHwsc3ms0L7vFAxCVKsRFuycHnjUkuBdcUEXI6fMY-NdjfYxuYhDcd-TPPwskAy6XkWEzYCWLXSHufpD5_tYU7uLeVsE4YbqD7jL9WiOKyqR7qfiTwYcEcVbJN6Mh2WeWqpGYOj16w16r2S8jxNwD0OHi_cm0s49G08vwwOdfmWHdVcCrXrBbIwF0u2gVyzypRAvFShFHn9bmlwCPGoJB8EC22aZBtrZUnICIFBoWnJWjlQGIHZSJuWdZ4xF3KMqSB4AOYELYmZCb6XtT0W7qQxMZo3FmYM-sfQZhgiwiLbg0zXMvOB21OMN8g0cVRhDj5PhQjMZwEolUJswXTyO9DErN50wln1XuDrpI7KTkMC5MycxZvI6K1LDxMSrTnhY0EV00gqikrt8BBsnkBJ_mPC8gAri6Xg_rsv8eJleZMFFFTnUnDDUPI63WeRvr4Gb6WwQfPjXmSikwS1PVOWpSXDgig-hksatvGr964PwiY4Dc08pGn4INsAkY-aUM5SedqfjMClHc-LhldZdwU2tZN5jS9dU__5Koiq8PX5crfXK9lkYU0Dze8U95b46TZRUI0fIibrCWrBe8xoJPS7WC8fefvCfkwk8nqM0VOIKk5tXj5FGRd2HCtWqN9dyvIcWGRuGCHjTVZ-vJdhOb39dB-nkwAWaJbucXvT9DMPmGEAyh8SYPURxCdP-aK9s3L2jroFjERt0OFx0Wds47An5-De7C6xR8PATQdiJTOtGI1V8HS_b-2pYdKRH5Y5xSJSamZ2qHjS7WCzx8ZOzc6WyobRsRMaI3xvzvq-soycuugG7edPtVo9Szg4Ma5cKvLYSq-DABXQYRA_RLYomW5tALFaWKTJOq7gtw8wFLdlAUyhPxY_vmII9SLOZF_ZuoFNf_dl-MFMJlTXqltqKdS1-PyOSszUT-jBMVOGK-R7gxKU_Hny9hJmVIdeowFUdK-wXJx-DfL1_FMle3ifO-Cc_xiTdKxvc98vDDBp5DzRVzVd_R7-nl-wd-jYVTK1_nW7teoU0zEkDV8YLcM67DwKBgsOkTW-gNoMNSF5RDpA7PacN8GqUN8MwAJ2n1NgREsBCi4YzxIAV-NBL7BFgEniIdpEBHQcTVOU0ctw4flsmpE0GoPnx9ZidaRpmT9XFgrvRrXWd-CsRDprP3JKoTfoMXT7uOJqt357C-KaeVanOVM4GSM26CrFPqaKYb9DH2W3jDzBXPrZexDwUPn6VsFfSvEruPTc5WWCFNmVfyryWP7pa93DV0XkOerTBsCG3TmskA9IBo0EvE0GF4OUEtt7GawY2mRwG9gRZLmll3ofQ83Ws-Y5eL-zr2JzK9F9z2z806aBSvkDSmUTBSUdar7DOIQ-ucyEHY32ISNfCNa-LCoqLRJAdEvRZdxgeTUyWaYCNsRwNPGWeaSQlgb1FwHtKVRZBpJGMGdL9qUvZqo0-kouc69EKfk_e1W_19mGwB5ct6tAEkYCC1DA_X8eZ1yovKm0aCXZNPfGsNiP5PXUDGtaQznKZWHkw8k9DnqTiYCHGP7WsEsb3nyDp16tZW9qeemf3zR1TevRjJmlsQtJxts9UzcXMy-kL13hl6uZp6ZrcN-MaMx_wXiJop5SL6jhsfHKqi_0U980Xckx8pBeX4YKPW_of7YYyqmJJbkZbJJkysyBcXQRXYO1YurwgDlYiZ9QeZ6lYGclSCRdTBkK5tlKhZJx1vxxeuQiEleqYTwvVWD2NpuoX2yWIufHH_taFH3uvvJkuB7NssJrswdYjq1qxlYaAyj0gVax08HonbWwFjOEwOSvKIS6ukhVlIyB0DJr0YJs7f496w5KVBTX_jVUhgte768xVGdHaElmwqG_poydp-hrF_rYF6-6u-7qUe1G8wfaZHCE6J0YdFZfx5ZJ8s8CJuWd0N9n7mtRjJqElmCAlz2fu_LNoWuG7mT-7W4LGHz1_Vr6DppnqYC47JHt3SWoSJAKRHHGFRZdW6a6fEe5aIy5KzgYs4oqQUgduPbSOlM1ZmRRa0gEKRlagco88F50uqWsQqCKQmBT6RMq531BVjWaPma7jR11B5xqS5V604IpPyhYbe6w802mnVHrBjlOlj95euWGaaohaGQ9OVz305mGh22BX0S881X17hMtutJY_wu0h1NnINS0kZkDweefYMU_-TWy0aVN2aLM2Mv6iXnA19l60G91QX81BFiXm-wa0m5285t8GejWlu3W517883iX1e2RgRX8gSTsN3mQGeHa3mdX00ARi2PPyFSHM-_zsLi-4ruf17V8btFyPtU2mK0jAxkGCR4ZU0U9EWD__wfgBeHWokPtfzXVVi8AeDLkWRDjxuHS5mO2F8Xv6sp7dtti8EFJ3TYEZONQGAAJhOQCD0G-wQaMN3_nGF6s9U2IwSPKEGd2XkZG12VAl743Y3tFq3EO5T6_-xwyKSfqTScQy-G-QZ7JBuxVe17o5RxkIiIxgzywIA0TZ21zT-HXt0XWpV0ypdfzwY5kuHMGCyqA6Y2MYAOOuN336Sk7tSO6GE13ZtFphoa8xF4bo7boE5NM2OeuSXJkSOCjQNOHf-hf76SHDd8X3YKa7qqPaTXdXr-HkuTgCckBUKu86zZ3lMmC9WbXr37a1USUEGVKujp6BxgoFAJlp41dttMzkQd63CmYpstrbLx3Rblm4
' Generated on: 2025-11-21T12:45:29.093529500

@startuml
skinparam classAttributeIconSize 0
hide circle

class ChainedCallNode {
  -token: Token
  -methodName: String
  -optionalChaining: ChainingNode
  -argList: List<ExpressionNode>
  -cachedMethod: Method
  -cachedCallingType: Type
  --
  +ChainedCallNode(token: Token, methodName: String)
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +setArgList(list: List<ExpressionNode>): void
  +getToken(): Token
  +getOptionalChaining(): ChainingNode
  +setOptChaining(chainingNode: ChainingNode): void
  +check(previousType: Type): Type
  +notPrimitiveCalling(callingType: Type): void
  +checkMethodExistence(callingType: Type, methodName: String, token: Token): Method
  +generateCode(): void
  -hasChainedCallWithReturn(): boolean
  +generateCode(isLeftSide: boolean): void
  +methodReturnsValue(): boolean
}

class ChainedVarNode {
  -token: Token
  -optionalChaining: ChainingNode
  -varName: String
  -attribute: Attribute
  --
  +ChainedVarNode(token: Token, varName: String)
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +generateCode(): void
  +generateCode(isLeftSideOfAssign: boolean): void
  +setOptChaining(chainingNode: ChainingNode): void
  +check(previousType: Type): Type
  -notPrimitiveCalling(callingType: Type): void
  -checkAttributeValidity(callingType: Type): void
}

abstract class ChainingNode {
  +check(check: Type): Type
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
}

class AssignNode {
  -left: ExpressionNode
  -right: ExpressionNode
  -token: Token
  -type: Type
  --
  +AssignNode(left: ExpressionNode, right: ExpressionNode, token: Token)
  +check(): Type
  +areConformantTypes(leftType: Type, rightType: Type): boolean
  +getLine(): int
  +getType(): Type
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +generateCode(isLeftSide: boolean): void
  +generateCode(): void
}

class BinaryExpNode {
  -operator: Token
  -leftSide: ExpressionNode
  -rightSide: ExpressionNode
  --
  +BinaryExpNode(leftSide: ExpressionNode, operator: Token, rightSide: ExpressionNode)
  +getOperator(): Token
  +getLeftSide(): ExpressionNode
  +getRightSide(): ExpressionNode
  +check(): Type
  +areConformantTypes(leftType: Type, rightType: Type): boolean
  +getExpectedTypes(operator: Token): Type
  +getResultType(operator: Token): Type
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  -generateOperator(): void
}

abstract class CompExpNode {
}

abstract class ExpressionNode {
  +isVariable(): boolean
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  +isConstructorCall(): boolean
  +isStaticCall(): boolean
  +setNeedsRMEM(b: boolean): void
}

class NullExpressionNode {
  +isVariable(): boolean
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
}

abstract class OperandNode {
  +getToken(): Token
  +setOptChaining(optChaining: ChainingNode): void
  +isConstructorCall(): boolean
  +isStaticCall(): boolean
}

class UnaryExpNode {
  -operator: Token
  -operand: OperandNode
  -type: Type
  --
  +UnaryExpNode(operator: Token, operand: OperandNode)
  +UnaryExpNode(operand: OperandNode)
  +check(): Type
  +getOperand(): OperandNode
  +getLine(): int
  +getType(): Type
  +getLexeme(): String
  +isAssign(): boolean
  +isConstructorCall(): boolean
  +isStaticCall(): boolean
  +setNeedsRMEM(b: boolean): void
  +isOperandWithCall(): boolean
  -operandIsBoolean(type: Type): boolean
  -operandIsInt(type: Type): boolean
  -operatorIsNegation(): boolean
  -operatorIsInt(): boolean
  +isVariable(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  -generateOperator(): void
}

class BooleanLiteralNode {
  -token: Token
  --
  +BooleanLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +generateCode(): void
}

class CharLiteralNode {
  -token: Token
  --
  +CharLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +generateCode(): void
}

class IntLiteralNode {
  -token: Token
  --
  +IntLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +generateCode(): void
}

abstract class LiteralNode {
  +isVariable(): boolean
  +getType(): Type
  +check(): Type
  +setOptChaining(optChaining: ChainingNode): void
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +generateCode(isLeftSide: boolean): void
}

class NullLiteralNode {
  -token: Token
  --
  +NullLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +generateCode(): void
}

class StringLiteralNode {
  -token: Token
  --
  +StringLiteralNode(token: Token)
  +getToken(): Token
  +getType(): Type
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +generateCode(): void
}

class ConstructorCallNode {
  -token: Token
  -className: String
  -optChaining: ChainingNode
  -argList: List<ExpressionNode>
  --
  +ConstructorCallNode(token: Token, className: String)
  +isConstructorCall(): boolean
  +setArgList(argList: List<ExpressionNode>): void
  +getArgList(): List<ExpressionNode>
  +getToken(): Token
  +getClassName(): String
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +generateCode(isLeftSide: boolean): void
  +generateCode(): void
  +isVariable(): boolean
}

class MethodCallNode {
  -token: Token
  -methodName: String
  -optChaining: ChainingNode
  -argList: List<ExpressionNode>
  --
  +MethodCallNode(token: Token, methodName: String)
  +setArgList(argList: List<ExpressionNode>): void
  +getArgList(): List<ExpressionNode>
  +getToken(): Token
  +getMethodName(): String
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isVariable(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  -findMethod(methodName: String): Method
}

class ParentizedExpressionNode {
  -expression: ExpressionNode
  -optionalChaining: ChainingNode
  -token: Token
  --
  +ParentizedExpressionNode(expression: ExpressionNode, token: Token)
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  +getToken(): Token
  +isVariable(): boolean
}

abstract class ReferenceNode {
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
}

class StaticMethodCallNode {
  -optionalChaining: ChainingNode
  -classToken: Token
  -methodToken: Token
  -argList: List<ExpressionNode>
  -needsRMEM: boolean = true
  --
  +StaticMethodCallNode(classToken: Token, methodToken: Token)
  +check(): Type
  -checkStaticMethodValidity(classToken: Token, methodToken: Token): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getArgList(): List<ExpressionNode>
  +setArgList(argList: List<ExpressionNode>): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isStaticCall(): boolean
  +setNeedsRMEM(needsRMEM: boolean): void
  +generateCode(): void
  +getToken(): Token
  +generateCode(isLeftSide: boolean): void
  +isVariable(): boolean
}

class ThisReferenceNode {
  -token: Token
  -className: String
  -optChaining: ChainingNode
  --
  +ThisReferenceNode(token: Token, className: String)
  +check(): Type
  +setOptChaining(chainingNode: ChainingNode): void
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  +getToken(): Token
  +isVariable(): boolean
}

class VarCallNode {
  -token: Token
  -varName: String
  -optChaining: ChainingNode
  --
  +VarCallNode(token: Token, varName: String)
  +getToken(): Token
  +getVarName(): String
  +setOptChaining(optChaining: ChainingNode): void
  +check(): Type
  +getLine(): int
  +getLexeme(): String
  +isAssign(): boolean
  +isOperandWithCall(): boolean
  +isParameter(): boolean
  +isLocalVar(): boolean
  +isAttribute(): boolean
  +isVariable(): boolean
  +generateCode(): void
  +generateCode(isLeftSide: boolean): void
  -generateParameterCode(): void
  -generateLocalVarCode(): void
  -generateAttributeCode(): void
  -generateLeftSideCode(): void
  -generateRightSideCode(): void
}

class BlockNode {
  -sentences: List<SentenceNode>
  -varLocalMap: LinkedHashMap<String, VarLocalNode>
  -nestedInClass: EntityClass
  -nestedInInvocable: Invocable
  -parentBlock: BlockNode
  -lastLocalVarOffset: int = 0
  --
  +BlockNode()
  +addSentence(sentence: SentenceNode): void
  +getSentences(): List<SentenceNode>
  +getVarLocalMap(): LinkedHashMap<String,VarLocalNode>
  +setParentBlock(parentBlock: BlockNode): void
  +getParentBlock(): BlockNode
  +setSentencesList(sentences: List<SentenceNode>): void
  +addVarLocal(varLocal: VarLocalNode): void
  +getLine(): int
  +getLexeme(): String
  +check(): void
  +generateCode(): void
}

class EmptySentenceNode {
  ~token: Token
  --
  +EmptySentenceNode()
  +EmptySentenceNode(token: Token)
  +check(): void
  +getLexeme(): String
  +getLine(): int
}

class ForStandardNode {
  -initialization: SentenceNode
  -condition: ExpressionNode
  -update: ExpressionNode
  -body: SentenceNode
  --
  +ForStandardNode(initialization: SentenceNode, condition: ExpressionNode, update: ExpressionNode)
  +check(): void
  +setBody(body: SentenceNode): void
}

class IfNode {
  -condition: ExpressionNode
  -body: SentenceNode
  -elseBody: SentenceNode
  -{static} labelCounter: int = 0
  --
  +IfNode(condition: ExpressionNode, body: SentenceNode, elseBody: SentenceNode)
  +check(): void
  +setBody(body: SentenceNode): void
  +getBody(): SentenceNode
  +getElseBody(): SentenceNode
  +generateCode(): void
  -bodyEndsInReturn(body: SentenceNode): boolean
}

class NullBlockNode {
  +NullBlockNode()
  +check(): void
}

class ReturnNode {
  -expectedType: Type
  -expressionNode: ExpressionNode
  -finalToken: Token
  -parameterCount: int
  --
  +ReturnNode(expressionNode: ExpressionNode)
  +check(): void
  +setFinalToken(finalToken: Token): void
  +getLexeme(): String
  +getLine(): int
  +generateCode(): void
  -calculateRetValOffset(): int
}

abstract class SentenceNode {
  +check(): void
  +isAssign(): boolean
  +getLine(): int
  +getLexeme(): String
  ~generateCode(): void
}

class SentenceWithExpressionNode {
  -expressionNode: ExpressionNode
  -finalToken: Token
  -expressionType: Type
  --
  +SentenceWithExpressionNode(expressionNode: ExpressionNode)
  +getExpressionNode(): ExpressionNode
  +check(): void
  +isAssign(): boolean
  +getLine(): int
  +getLexeme(): String
  +setFinalToken(finalToken: Token): void
  +getFinalToken(): Token
  +generateCode(): void
  -expressionReturnsVoid(): boolean
}

class VarLocalNode {
  -type: Type
  -id: String
  -value: ExpressionNode
  -token: Token
  -assignToken: Token
  -offset: int
  --
  +VarLocalNode(type: Type, token: Token)
  +VarLocalNode(token: Token, value: ExpressionNode, assignToken: Token)
  +getLexeme(): String
  +getValue(): ExpressionNode
  +getLine(): int
  +getType(): Type
  +getId(): String
  +isAssign(): boolean
  +check(): void
  -checkNoParentBlocksContainVar(): void
  +generateCode(): void
  +getOffset(): int
  +setOffset(offset: int): void
}

class WhileNode {
  -condition: ExpressionNode
  -body: SentenceNode
  -{static} labelCounter: int = 0
  --
  +WhileNode(condition: ExpressionNode, body: SentenceNode)
  +check(): void
  +setBody(body: SentenceNode): void
  +getBody(): SentenceNode
  +getCondition(): ExpressionNode
  +generateCode(): void
}

class Attribute {
  -idToken: Token
  -type: Type
  -visibility: Token
  -value: ExpressionNode
  -offset: int
  --
  +Attribute(idToken: Token, type: Type, visibility: Token)
  +getName(): String
  +getLine(): int
  +getType(): Type
  +isPublic(): boolean
  +getVisibility(): Token
  +setValue(value: ExpressionNode): void
  +getValue(): ExpressionNode
  +estaBienDeclarado(): void
  +chequeoSentencias(): void
  +getOffset(): int
  +setOffset(offset: int): void
}

class Constructor {
  -idToken: Token
  -visibility: Token
  -parameters: HashMap<String, Parameter>
  -paramList: List<Parameter>
  -block: BlockNode
  -ownerClass: EntityClass
  -label: String
  --
  +Constructor(idToken: Token, visibility: Token)
  +setBlock(block: BlockNode): void
  +getBlock(): BlockNode
  +getName(): String
  +getVisibility(): Token
  +getParamList(): List<Parameter>
  +getLine(): int
  +addParameter(parameter: Parameter): void
  +setOwnerClass(ownerClass: EntityClass): void
  +isPublic(): boolean
  +isStaticMethod(): boolean
  +isVoid(): boolean
  +estaBienDeclarado(): void
  +chequeoSentencias(): void
  +getLabel(): String
  +generateCode(): void
}

interface Invocable {
  ~getName(): String
  ~setBlock(block: BlockNode): void
  ~getBlock(): BlockNode
  ~getLine(): int
  ~estaBienDeclarado(): void
  ~chequeoSentencias(): void
  ~getParamList(): List<Parameter>
  ~getVisibility(): Token
  ~addParameter(param: Parameter): void
  ~isPublic(): boolean
  ~isStaticMethod(): boolean
  ~isVoid(): boolean
}

class Method {
  -parameters: HashMap<String, Parameter>
  -paramList: List<Parameter>
  -idToken: Token
  -returnType: Type
  -modifier: Token
  -visibility: Token
  -hasBody: boolean
  -block: BlockNode
  -ownerClass: EntityClass
  -explicitReturn: boolean
  -offset: int
  -label: String
  --
  +Method(idToken: Token, returnType: Type, modifier: Token, visibility: Token)
  +Method(idToken: Token, returnType: Type, modifier: Token)
  +addParameter(parameter: Parameter): void
  +isPublic(): boolean
  +isStaticMethod(): boolean
  +setBlock(block: BlockNode): void
  +setExplicitReturn(explicitReturn: boolean): void
  +hasExplicitReturn(): boolean
  +getBlock(): BlockNode
  +hasBody(): boolean
  +setHasBody(hasBody: boolean): void
  +getVisibility(): Token
  +getName(): String
  +getLine(): int
  +getParamList(): List<Parameter>
  +getReturnType(): Type
  +getModifier(): Token
  +getOwnerClass(): EntityClass
  +estaBienDeclarado(): void
  +chequeoSentencias(): void
  +generateCode(): void
  +getLabel(): String
  +setOffset(offset: int): void
  +getOffset(): int
  +isVoid(): boolean
  +setOwnerClass(objectClass: EntityClass): void
}

class Parameter {
  -idToken: Token
  -type: Type
  -offset: int
  --
  +Parameter(idToken: Token, type: Type)
  +getName(): String
  +getLine(): int
  +getType(): Type
  +estaBienDeclarado(): void
  +setOffset(offset: int): void
  +getOffset(): int
}

class ConcreteClass {
  ~idToken: Token
  ~herencia: Token
  ~implementation: Token
  ~modificador: Token
  ~attributes: HashMap<String, Attribute>
  ~shadowedAttributes: HashMap<String, Attribute>
  ~methods: HashMap<String, Method>
  ~inheritedMethods: HashMap<String, Method>
  ~redefinedMethods: HashMap<String, Method>
  ~inheritedAtts: HashMap<String, Attribute>
  ~constructor: Constructor
  ~consolidated: boolean
  ~predefined: boolean = false
  ~methodsOffsets: boolean = false
  ~attributesOffsets: boolean = false
  -VTLabel: String
  --
  +ConcreteClass(idToken: Token, modificador: Token)
  +consolidated(): boolean
  +methodOffsetsSet(): boolean
  +setMethodOffsetsSet(methodOffsetsSet: boolean): void
  -notObjectClass(): boolean
  +estaBienDeclarado(): void
  +isPredefined(): boolean
  +setPredefined(predefined: boolean): void
  +chequeoSentencias(): void
  ~checkDeadCode(sentence: SentenceNode, reachable: boolean): boolean
  +checkInheritance(): void
  +isAbstract(): boolean
  +isFinal(): boolean
  +isStatic(): boolean
  -imObject(): boolean
  +consolidar(): void
  -consolidatedParent(): void
  -implementMethod(method: Method): void
  -inheriteAttribute(attribute: Attribute): void
  -inheriteMethod(method: Method): void
  -checkVisibilityModifier(method: Method, existingMethod: Method): void
  -checkAbstractModifier(method: Method): void
  -checkMethodModifier(method: Method, existingMethod: Method): void
  +isClass(): boolean
  +isInterface(): boolean
  +getName(): String
  +getLine(): int
  +getModificador(): Token
  +getAttributes(): HashMap<String,Attribute>
  +getMethods(): HashMap<String,Method>
  +getInheritedMethods(): HashMap<String,Method>
  +getInheritedAttributes(): HashMap<String,Attribute>
  +getConstructor(): Constructor
  +getHerencia(): Token
  +addAttribute(attribute: Attribute): void
  +addMethod(method: Method): void
  +addConstructor(constructor: Constructor): void
  +addInheritance(herencia: Token): void
  +addImplementation(implementation: Token): void
  -checkImplementation(): void
  -checkCircularInheritance(herencia: Token): void
  +getVTLabel(): String
  +generateCode(): void
  +generateVirtualTable(): void
  +getCIRSize(): int
  +setOffsets(): void
  +setAttributeOffsets(): void
  +setMethodsOffsets(): void
  +getNextMethodOffset(): int
}

interface EntityClass {
  ~methodOffsetsSet(): boolean
  ~setMethodOffsetsSet(methodOffsetsSet: boolean): void
  ~estaBienDeclarado(): void
  ~consolidar(): void
  ~chequeoSentencias(): void
  ~getName(): String
  ~getLine(): int
  ~getModificador(): Token
  ~getHerencia(): Token
  ~getMethods(): java.util.HashMap<String,Method>
  ~getInheritedMethods(): java.util.HashMap<String,Method>
  ~getInheritedAttributes(): java.util.HashMap<String,Attribute>
  ~getAttributes(): java.util.HashMap<String,Attribute>
  ~getConstructor(): Constructor
  ~isAbstract(): boolean
  ~isStatic(): boolean
  ~isFinal(): boolean
  ~isClass(): boolean
  ~isInterface(): boolean
  ~consolidated(): boolean
  ~isPredefined(): boolean
  ~setPredefined(predefined: boolean): void
  ~generateCode(): void
  ~setMethodsOffsets(): void
  ~setAttributeOffsets(): void
  +getNextMethodOffset(): int
  ~addAttribute(attribute: Attribute): void
  ~addMethod(method: Method): void
  ~addConstructor(constructor: Constructor): void
  ~addInheritance(herencia: Token): void
  ~setOffsets(): void
  ~getVTLabel(): String
  ~getCIRSize(): int
}

class Interface {
  -idToken: Token
  -herencia: Token
  -modificador: Token
  ~methods: HashMap<String, Method>
  ~inheritedMethods: HashMap<String, Method>
  ~inheritedAtts: HashMap<String, Attribute>
  ~attributes: HashMap<String, Attribute>
  -consolidated: boolean
  -isPredefined: boolean = false
  -vtLabel: String
  --
  +Interface(idToken: Token, modificador: Token)
  +methodOffsetsSet(): boolean
  +setMethodOffsetsSet(methodOffsetsSet: boolean): void
  +estaBienDeclarado(): void
  +consolidated(): boolean
  +consolidar(): void
  +isPredefined(): boolean
  +setPredefined(predefined: boolean): void
  +generateCode(): void
  +setMethodsOffsets(): void
  +setAttributeOffsets(): void
  +getNextMethodOffset(): int
  +chequeoSentencias(): void
  -consolidatedParent(): void
  -inheritanceAttribute(attribute: Attribute): void
  -inheritanceMethod(m: Method): void
  +isInterface(): boolean
  +getHerencia(): Token
  +getModificador(): Token
  +getName(): String
  +getMethods(): HashMap<String,Method>
  +getInheritedMethods(): HashMap<String,Method>
  +getInheritedAttributes(): HashMap<String,Attribute>
  +getLine(): int
  +getAttributes(): HashMap<String,Attribute>
  +getConstructor(): Constructor
  -checkVisibilityModifier(method: Method, existingMethod: Method): void
  +addMethod(method: Method): void
  +addInheritance(herencia: Token): void
  +setOffsets(): void
  +getVTLabel(): String
  +getCIRSize(): int
  -checkInheritance(): void
  -checkCircularInheritance(herencia: Token): void
  +addAttribute(attribute: Attribute): void
  +addConstructor(constructor: Constructor): void
  +isAbstract(): boolean
  +isClass(): boolean
  +isStatic(): boolean
  +isFinal(): boolean
}

class SymbolTable {
  +claseActual: EntityClass
  ~attributeActual: Attribute
  ~currentInvocable: Invocable
  ~constructorActual: Constructor
  ~methodActual: Method
  +clases: HashMap<String, EntityClass>
  ~currentBlock: BlockNode
  +instructionList: List<String>
  -stringLiteralLabels: HashMap<String, String> = new HashMap<>()
  -stringLiteralCounter: int = 0
  --
  +SymbolTable()
  +createPredefinedClasses(): void
  +chequeoDeclaraciones(): void
  +chequeoSentencias(): void
  +setCurrentClass(lexeme: String, nuevaClase: EntityClass): void
  +addCurrentClass(): void
  +setCurrentInvocable(invocable: Invocable): void
  +getCurrentInvocable(): Invocable
  +setCurrentMethod(method: Method): void
  +addCurrentMethod(): void
  +setCurrentConstructor(constructor: Constructor): void
  +addCurrentConstructor(): void
  +setCurrentBlock(block: BlockNode): void
  +getCurrentMethod(): Method
  +getCurrentClass(): EntityClass
  +getCurrentBlock(): BlockNode
  +getCurrentConstructor(): Constructor
  +getCurrentAttribute(): Attribute
  +setCurrentAttribute(attribute: Attribute): void
  +getClass(lexeme: String): EntityClass
  +classExists(lexeme: String): boolean
  +isParameter(id: String): boolean
  +isLocalVar(id: String): boolean
  +getLocalVarType(id: String): Type
  +isAttribute(id: String): boolean
  +getParameter(id: String): Parameter
  +checkCompatibility(leftType: ReferenceType, rightType: ReferenceType): boolean
  +generateCode(): void
  +generatePredefinedData(): void
  -initGenerator(): void
  -heapRoutinesGenerator(): void
  -defaultClassesGenerator(): void
  -setOffsets(): void
  +getLocalVarOffset(varName: String): int
  +getOrCreateStringLiteralLabel(lexeme: String): String
  -generateStringLiterals(): void
}

class BooleanType {
  +BooleanType()
  +isSubtypeOf(rightType: Type): boolean
}

class CharType {
  +CharType()
  +isSubtypeOf(rightType: Type): boolean
}

class IntType {
  +IntType()
  +isSubtypeOf(rightType: Type): boolean
}

class NullType {
  -token: Token
  --
  +NullType(token: Token)
  +isSubtypeOf(rightType: Type): boolean
}

abstract class PrimitiveType {
  -name: String
  --
  +PrimitiveType(name: String)
  +isPrimitive(): boolean
  +getName(): String
  +getLine(): int
}

class ReferenceType {
  -classIdName: Token
  --
  +ReferenceType(name: Token)
  +isPrimitive(): boolean
  +getName(): String
  +getLine(): int
  +isSubtypeOf(rightType: Type): boolean
}

interface Type {
  ~isPrimitive(): boolean
  ~getName(): String
  ~getLine(): int
  ~isSubtypeOf(rightType: Type): boolean
}

class VoidType {
  +VoidType()
  +isSubtypeOf(rightType: Type): boolean
}

ChainedCallNode --|> ChainingNode
ChainedCallNode *-- ChainingNode
ChainedCallNode o-- ExpressionNode
ChainedCallNode *-- Method
ChainedCallNode *-- Type
ChainedVarNode --|> ChainingNode
ChainedVarNode *-- ChainingNode
ChainedVarNode *-- Attribute
ChainedVarNode ..> Type
ChainingNode ..> Type
AssignNode --|> ExpressionNode
AssignNode *-- ExpressionNode
AssignNode *-- Type
BinaryExpNode --|> CompExpNode
BinaryExpNode *-- ExpressionNode
BinaryExpNode ..> Type
CompExpNode --|> ExpressionNode
ExpressionNode ..> Type
NullExpressionNode --|> ExpressionNode
NullExpressionNode ..> Type
OperandNode --|> ExpressionNode
OperandNode ..> ChainingNode
UnaryExpNode --|> CompExpNode
UnaryExpNode *-- OperandNode
UnaryExpNode *-- Type
BooleanLiteralNode --|> LiteralNode
BooleanLiteralNode ..> Type
CharLiteralNode --|> LiteralNode
CharLiteralNode ..> Type
IntLiteralNode --|> LiteralNode
IntLiteralNode ..> Type
LiteralNode --|> OperandNode
LiteralNode ..> Type
LiteralNode ..> ChainingNode
NullLiteralNode --|> LiteralNode
NullLiteralNode ..> Type
StringLiteralNode --|> LiteralNode
StringLiteralNode ..> Type
ConstructorCallNode --|> ReferenceNode
ConstructorCallNode *-- ChainingNode
ConstructorCallNode o-- ExpressionNode
ConstructorCallNode ..> Type
MethodCallNode --|> ReferenceNode
MethodCallNode *-- ChainingNode
MethodCallNode o-- ExpressionNode
MethodCallNode ..> Type
MethodCallNode ..> Method
ParentizedExpressionNode --|> ReferenceNode
ParentizedExpressionNode *-- ExpressionNode
ParentizedExpressionNode *-- ChainingNode
ParentizedExpressionNode ..> Type
ReferenceNode --|> OperandNode
ReferenceNode ..> Type
ReferenceNode ..> ChainingNode
StaticMethodCallNode --|> ReferenceNode
StaticMethodCallNode *-- ChainingNode
StaticMethodCallNode o-- ExpressionNode
StaticMethodCallNode ..> Type
ThisReferenceNode --|> ReferenceNode
ThisReferenceNode *-- ChainingNode
ThisReferenceNode ..> Type
VarCallNode --|> ReferenceNode
VarCallNode *-- ChainingNode
VarCallNode ..> Type
BlockNode --|> SentenceNode
BlockNode o-- SentenceNode
BlockNode o-- VarLocalNode
BlockNode *-- EntityClass
BlockNode *-- Invocable
BlockNode *-- BlockNode
EmptySentenceNode --|> SentenceNode
ForStandardNode --|> SentenceNode
ForStandardNode *-- SentenceNode
ForStandardNode *-- ExpressionNode
IfNode --|> SentenceNode
IfNode *-- ExpressionNode
IfNode *-- SentenceNode
NullBlockNode --|> BlockNode
ReturnNode --|> SentenceWithExpressionNode
ReturnNode *-- Type
ReturnNode *-- ExpressionNode
SentenceWithExpressionNode --|> SentenceNode
SentenceWithExpressionNode *-- ExpressionNode
SentenceWithExpressionNode *-- Type
VarLocalNode --|> SentenceNode
VarLocalNode *-- Type
VarLocalNode *-- ExpressionNode
WhileNode --|> SentenceNode
WhileNode *-- ExpressionNode
WhileNode *-- SentenceNode
Attribute *-- Type
Attribute *-- ExpressionNode
Constructor ..|> Invocable
Constructor o-- Parameter
Constructor *-- BlockNode
Constructor *-- EntityClass
Invocable ..> BlockNode
Invocable ..> Parameter
Method ..|> Invocable
Method o-- Parameter
Method *-- Type
Method *-- BlockNode
Method *-- EntityClass
Parameter *-- Type
ConcreteClass ..|> EntityClass
ConcreteClass o-- Attribute
ConcreteClass o-- Method
ConcreteClass --> Constructor
ConcreteClass ..> SentenceNode
EntityClass ..> Constructor
EntityClass ..> Attribute
EntityClass ..> Method
Interface ..|> EntityClass
Interface o-- Method
Interface o-- Attribute
Interface ..> Constructor
SymbolTable --> EntityClass
SymbolTable --> Attribute
SymbolTable --> Invocable
SymbolTable --> Constructor
SymbolTable --> Method
SymbolTable o-- EntityClass
SymbolTable --> BlockNode
SymbolTable ..> Type
SymbolTable ..> Parameter
SymbolTable ..> ReferenceType
BooleanType --|> PrimitiveType
BooleanType ..> Type
CharType --|> PrimitiveType
CharType ..> Type
IntType --|> PrimitiveType
IntType ..> Type
NullType --|> ReferenceType
NullType ..> Type
PrimitiveType ..|> Type
ReferenceType ..|> Type
Type ..> Type
VoidType --|> PrimitiveType
VoidType ..> Type
@enduml